{"ast":null,"code":"import EventEmitter from \"events\";\nimport { TransportRaceCondition, TransportError, StatusCodes, getAltStatusMessage, TransportStatusError } from \"@ledgerhq/errors\";\nimport { LocalTracer } from \"@ledgerhq/logs\";\nexport { TransportError, TransportStatusError, StatusCodes, getAltStatusMessage };\nconst DEFAULT_LOG_TYPE = \"transport\";\n/**\n * The Transport class defines a generic interface for communicating with a Ledger hardware wallet.\n * There are different kind of transports based on the technology (channels like U2F, HID, Bluetooth, Webusb) and environment (Node, Web,...).\n * It is an abstract class that needs to be implemented.\n */\nexport default class Transport {\n  exchangeTimeout = 30000;\n  unresponsiveTimeout = 15000;\n  deviceModel = null;\n  tracer;\n  constructor({\n    context,\n    logType\n  } = {}) {\n    this.tracer = new LocalTracer(logType ?? DEFAULT_LOG_TYPE, context);\n  }\n  /**\n   * Check if the transport is supported on the current platform/browser.\n   * @returns {Promise<boolean>} A promise that resolves with a boolean indicating support.\n   */\n  static isSupported;\n  /**\n   * List all available descriptors for the transport.\n   * For a better granularity, checkout `listen()`.\n   *\n   * @returns {Promise<Array<any>>} A promise that resolves with an array of descriptors.\n   * @example\n   * TransportFoo.list().then(descriptors => ...)\n   */\n  static list;\n  /**\n   * Listen for device events for the transport. The method takes an observer of DescriptorEvent and returns a Subscription.\n   * A DescriptorEvent is an object containing a \"descriptor\" and a \"type\" field. The \"type\" field can be \"add\" or \"remove\", and the \"descriptor\" field can be passed to the \"open\" method.\n   * The \"listen\" method will first emit all currently connected devices and then will emit events as they occur, such as when a USB device is plugged in or a Bluetooth device becomes discoverable.\n   * @param {Observer<DescriptorEvent<any>>} observer - An object with \"next\", \"error\", and \"complete\" functions, following the observer pattern.\n   * @returns {Subscription} A Subscription object on which you can call \".unsubscribe()\" to stop listening to descriptors.\n   * @example\n  const sub = TransportFoo.listen({\n  next: e => {\n    if (e.type===\"add\") {\n      sub.unsubscribe();\n      const transport = await TransportFoo.open(e.descriptor);\n      ...\n    }\n  },\n  error: error => {},\n  complete: () => {}\n  })\n   */\n  static listen;\n  /**\n   * Attempt to create a Transport instance with a specific descriptor.\n   * @param {any} descriptor - The descriptor to open the transport with.\n   * @param {number} timeout - An optional timeout for the transport connection.\n   * @param {TraceContext} context Optional tracing/log context\n   * @returns {Promise<Transport>} A promise that resolves with a Transport instance.\n   * @example\n  TransportFoo.open(descriptor).then(transport => ...)\n   */\n  static open;\n  /**\n   * Send data to the device using a low level API.\n   * It's recommended to use the \"send\" method for a higher level API.\n   * @param {Buffer} apdu - The data to send.\n   * @param {Object} options - Contains optional options for the exchange function\n   *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n   */\n  exchange(_apdu, {\n    abortTimeoutMs: _abortTimeoutMs\n  } = {}) {\n    throw new Error(\"exchange not implemented\");\n  }\n  /**\n   * Send apdus in batch to the device using a low level API.\n   * The default implementation is to call exchange for each apdu.\n   * @param {Array<Buffer>} apdus - array of apdus to send.\n   * @param {Observer<Buffer>} observer - an observer that will receive the response of each apdu.\n   * @returns {Subscription} A Subscription object on which you can call \".unsubscribe()\" to stop sending apdus.\n   */\n  exchangeBulk(apdus, observer) {\n    let unsubscribed = false;\n    const unsubscribe = () => {\n      unsubscribed = true;\n    };\n    const main = async () => {\n      if (unsubscribed) return;\n      for (const apdu of apdus) {\n        const r = await this.exchange(apdu);\n        if (unsubscribed) return;\n        const status = r.readUInt16BE(r.length - 2);\n        if (status !== StatusCodes.OK) {\n          throw new TransportStatusError(status);\n        }\n        observer.next(r);\n      }\n    };\n    main().then(() => !unsubscribed && observer.complete(), e => !unsubscribed && observer.error(e));\n    return {\n      unsubscribe\n    };\n  }\n  /**\n   * Set the \"scramble key\" for the next data exchanges with the device.\n   * Each app can have a different scramble key and it is set internally during instantiation.\n   * @param {string} key - The scramble key to set.\n   * deprecated This method is no longer needed for modern transports and should be migrated away from.\n   * no @ before deprecated as it breaks documentationjs on version 14.0.2\n   * https://github.com/documentationjs/documentation/issues/1596\n   */\n  setScrambleKey(_key) {}\n  /**\n   * Close the connection with the device.\n   *\n   * Note: for certain transports (hw-transport-node-hid-singleton for ex), once the promise resolved,\n   * the transport instance is actually still cached, and the device is disconnected only after a defined timeout.\n   * But for the consumer of the Transport, this does not matter and it can consider the transport to be closed.\n   *\n   * @returns {Promise<void>} A promise that resolves when the transport is closed.\n   */\n  close() {\n    return Promise.resolve();\n  }\n  _events = new EventEmitter();\n  /**\n   * Listen for an event on the transport instance.\n   * Transport implementations may have specific events. Common events include:\n   * \"disconnect\" : triggered when the transport is disconnected.\n   * @param {string} eventName - The name of the event to listen for.\n   * @param {(...args: Array<any>) => any} cb - The callback function to be invoked when the event occurs.\n   */\n  on(eventName, cb) {\n    this._events.on(eventName, cb);\n  }\n  /**\n   * Stop listening to an event on an instance of transport.\n   */\n  off(eventName, cb) {\n    this._events.removeListener(eventName, cb);\n  }\n  emit(event, ...args) {\n    this._events.emit(event, ...args);\n  }\n  /**\n   * Enable or not logs of the binary exchange\n   */\n  setDebugMode() {\n    console.warn(\"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\");\n  }\n  /**\n   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n   */\n  setExchangeTimeout(exchangeTimeout) {\n    this.exchangeTimeout = exchangeTimeout;\n  }\n  /**\n   * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n   */\n  setExchangeUnresponsiveTimeout(unresponsiveTimeout) {\n    this.unresponsiveTimeout = unresponsiveTimeout;\n  }\n  /**\n   * Send data to the device using the higher level API.\n   *\n   * @param {number} cla - The instruction class for the command.\n   * @param {number} ins - The instruction code for the command.\n   * @param {number} p1 - The first parameter for the instruction.\n   * @param {number} p2 - The second parameter for the instruction.\n   * @param {Buffer} data - The data to be sent. Defaults to an empty buffer.\n   * @param {Array<number>} statusList - A list of acceptable status codes for the response. Defaults to [StatusCodes.OK].\n   * @param {Object} options - Contains optional options for the exchange function\n   *  - abortTimeoutMs: stop the send after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n   */\n  send = async (cla, ins, p1, p2, data = Buffer.alloc(0), statusList = [StatusCodes.OK], {\n    abortTimeoutMs\n  } = {}) => {\n    const tracer = this.tracer.withUpdatedContext({\n      function: \"send\"\n    });\n    if (data.length >= 256) {\n      tracer.trace(\"data.length exceeded 256 bytes limit\", {\n        dataLength: data.length\n      });\n      throw new TransportError(\"data.length exceed 256 bytes limit. Got: \" + data.length, \"DataLengthTooBig\");\n    }\n    tracer.trace(\"Starting an exchange\", {\n      abortTimeoutMs\n    });\n    const response = await this.exchange(\n    // The size of the data is added in 1 byte just before `data`\n    Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]), {\n      abortTimeoutMs\n    });\n    tracer.trace(\"Received response from exchange\");\n    const sw = response.readUInt16BE(response.length - 2);\n    if (!statusList.some(s => s === sw)) {\n      throw new TransportStatusError(sw);\n    }\n    return response;\n  };\n  /**\n   * create() allows to open the first descriptor available or\n   * throw if there is none or if timeout is reached.\n   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n   * @example\n  TransportFoo.create().then(transport => ...)\n   */\n  static create(openTimeout = 3000, listenTimeout) {\n    return new Promise((resolve, reject) => {\n      let found = false;\n      const sub = this.listen({\n        next: e => {\n          found = true;\n          if (sub) sub.unsubscribe();\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          this.open(e.descriptor, openTimeout).then(resolve, reject);\n        },\n        error: e => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          reject(e);\n        },\n        complete: () => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          if (!found) {\n            reject(new TransportError(this.ErrorMessage_NoDeviceFound, \"NoDeviceFound\"));\n          }\n        }\n      });\n      const listenTimeoutId = listenTimeout ? setTimeout(() => {\n        sub.unsubscribe();\n        reject(new TransportError(this.ErrorMessage_ListenTimeout, \"ListenTimeout\"));\n      }, listenTimeout) : null;\n    });\n  }\n  // Blocks other exchange to happen concurrently\n  exchangeBusyPromise;\n  /**\n   * Wrapper to make an exchange \"atomic\" (blocking any other exchange)\n   *\n   * It also handles \"unresponsiveness\" by emitting \"unresponsive\" and \"responsive\" events.\n   *\n   * @param f The exchange job, using the transport to run\n   * @returns a Promise resolving with the output of the given job\n   */\n  async exchangeAtomicImpl(f) {\n    const tracer = this.tracer.withUpdatedContext({\n      function: \"exchangeAtomicImpl\",\n      unresponsiveTimeout: this.unresponsiveTimeout\n    });\n    if (this.exchangeBusyPromise) {\n      tracer.trace(\"Atomic exchange is already busy\");\n      throw new TransportRaceCondition(\"An action was already pending on the Ledger device. Please deny or reconnect.\");\n    }\n    // Sets the atomic guard\n    let resolveBusy;\n    const busyPromise = new Promise(r => {\n      resolveBusy = r;\n    });\n    this.exchangeBusyPromise = busyPromise;\n    // The device unresponsiveness handler\n    let unresponsiveReached = false;\n    const timeout = setTimeout(() => {\n      tracer.trace(`Timeout reached, emitting Transport event \"unresponsive\"`, {\n        unresponsiveTimeout: this.unresponsiveTimeout\n      });\n      unresponsiveReached = true;\n      this.emit(\"unresponsive\");\n    }, this.unresponsiveTimeout);\n    try {\n      const res = await f();\n      if (unresponsiveReached) {\n        tracer.trace(\"Device was unresponsive, emitting responsive\");\n        this.emit(\"responsive\");\n      }\n      return res;\n    } finally {\n      tracer.trace(\"Finalize, clearing busy guard\");\n      clearTimeout(timeout);\n      if (resolveBusy) resolveBusy();\n      this.exchangeBusyPromise = null;\n    }\n  }\n  decorateAppAPIMethods(self, methods, scrambleKey) {\n    for (const methodName of methods) {\n      self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);\n    }\n  }\n  _appAPIlock = null;\n  decorateAppAPIMethod(methodName, f, ctx, scrambleKey) {\n    return async (...args) => {\n      const {\n        _appAPIlock\n      } = this;\n      if (_appAPIlock) {\n        return Promise.reject(new TransportError(\"Ledger Device is busy (lock \" + _appAPIlock + \")\", \"TransportLocked\"));\n      }\n      try {\n        this._appAPIlock = methodName;\n        this.setScrambleKey(scrambleKey);\n        return await f.apply(ctx, args);\n      } finally {\n        this._appAPIlock = null;\n      }\n    };\n  }\n  /**\n   * Sets the context used by the logging/tracing mechanism\n   *\n   * Useful when re-using (cached) the same Transport instance,\n   * but with a new tracing context.\n   *\n   * @param context A TraceContext, that can undefined to reset the context\n   */\n  setTraceContext(context) {\n    this.tracer = this.tracer.withContext(context);\n  }\n  /**\n   * Updates the context used by the logging/tracing mechanism\n   *\n   * The update only overrides the key-value that are already defined in the current context.\n   *\n   * @param contextToAdd A TraceContext that will be added to the current context\n   */\n  updateTraceContext(contextToAdd) {\n    this.tracer.updateContext(contextToAdd);\n  }\n  /**\n   * Gets the tracing context of the transport instance\n   */\n  getTraceContext() {\n    return this.tracer.getContext();\n  }\n  static ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\n  static ErrorMessage_NoDeviceFound = \"No Ledger device found\";\n}","map":{"version":3,"names":["EventEmitter","TransportRaceCondition","TransportError","StatusCodes","getAltStatusMessage","TransportStatusError","LocalTracer","DEFAULT_LOG_TYPE","Transport","exchangeTimeout","unresponsiveTimeout","deviceModel","tracer","constructor","context","logType","isSupported","list","listen","open","exchange","_apdu","abortTimeoutMs","_abortTimeoutMs","Error","exchangeBulk","apdus","observer","unsubscribed","unsubscribe","main","apdu","r","status","readUInt16BE","length","OK","next","then","complete","e","error","setScrambleKey","_key","close","Promise","resolve","_events","on","eventName","cb","off","removeListener","emit","event","args","setDebugMode","console","warn","setExchangeTimeout","setExchangeUnresponsiveTimeout","send","cla","ins","p1","p2","data","Buffer","alloc","statusList","withUpdatedContext","function","trace","dataLength","response","concat","from","sw","some","s","create","openTimeout","listenTimeout","reject","found","sub","listenTimeoutId","clearTimeout","descriptor","ErrorMessage_NoDeviceFound","setTimeout","ErrorMessage_ListenTimeout","exchangeBusyPromise","exchangeAtomicImpl","f","resolveBusy","busyPromise","unresponsiveReached","timeout","res","decorateAppAPIMethods","self","methods","scrambleKey","methodName","decorateAppAPIMethod","_appAPIlock","ctx","apply","setTraceContext","withContext","updateTraceContext","contextToAdd","updateContext","getTraceContext","getContext"],"sources":["/home/kokoi/typeracer-app/frontend/node_modules/@ledgerhq/hw-transport/src/Transport.ts"],"sourcesContent":["import EventEmitter from \"events\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport {\n  TransportRaceCondition,\n  TransportError,\n  StatusCodes,\n  getAltStatusMessage,\n  TransportStatusError,\n} from \"@ledgerhq/errors\";\nimport { LocalTracer, TraceContext, LogType } from \"@ledgerhq/logs\";\nexport { TransportError, TransportStatusError, StatusCodes, getAltStatusMessage };\n\nconst DEFAULT_LOG_TYPE = \"transport\";\n\n/**\n */\nexport type Subscription = {\n  unsubscribe: () => void;\n};\n\n/**\n */\nexport type Device = any; // Should be a union type of all possible Device object's shape\n\nexport type DescriptorEventType = \"add\" | \"remove\";\n/**\n * A \"descriptor\" is a parameter that is specific to the implementation, and can be an ID, file path, or URL.\n * type: add or remove event\n * descriptor: a parameter that can be passed to open(descriptor)\n * deviceModel: device info on the model (is it a nano s, nano x, ...)\n * device: transport specific device info\n */\nexport interface DescriptorEvent<Descriptor> {\n  type: DescriptorEventType;\n  descriptor: Descriptor;\n  deviceModel?: DeviceModel | null | undefined;\n  device?: Device;\n}\n\n/**\n * Observer generic type, following the Observer pattern\n */\nexport type Observer<EventType, EventError = unknown> = Readonly<{\n  next: (event: EventType) => unknown;\n  error: (e: EventError) => unknown;\n  complete: () => unknown;\n}>;\n\n/**\n * The Transport class defines a generic interface for communicating with a Ledger hardware wallet.\n * There are different kind of transports based on the technology (channels like U2F, HID, Bluetooth, Webusb) and environment (Node, Web,...).\n * It is an abstract class that needs to be implemented.\n */\nexport default class Transport {\n  exchangeTimeout = 30000;\n  unresponsiveTimeout = 15000;\n  deviceModel: DeviceModel | null | undefined = null;\n  tracer: LocalTracer;\n\n  constructor({ context, logType }: { context?: TraceContext; logType?: LogType } = {}) {\n    this.tracer = new LocalTracer(logType ?? DEFAULT_LOG_TYPE, context);\n  }\n\n  /**\n   * Check if the transport is supported on the current platform/browser.\n   * @returns {Promise<boolean>} A promise that resolves with a boolean indicating support.\n   */\n  static readonly isSupported: () => Promise<boolean>;\n\n  /**\n   * List all available descriptors for the transport.\n   * For a better granularity, checkout `listen()`.\n   *\n   * @returns {Promise<Array<any>>} A promise that resolves with an array of descriptors.\n   * @example\n   * TransportFoo.list().then(descriptors => ...)\n   */\n  static readonly list: () => Promise<Array<any>>;\n\n  /**\n   * Listen for device events for the transport. The method takes an observer of DescriptorEvent and returns a Subscription.\n   * A DescriptorEvent is an object containing a \"descriptor\" and a \"type\" field. The \"type\" field can be \"add\" or \"remove\", and the \"descriptor\" field can be passed to the \"open\" method.\n   * The \"listen\" method will first emit all currently connected devices and then will emit events as they occur, such as when a USB device is plugged in or a Bluetooth device becomes discoverable.\n   * @param {Observer<DescriptorEvent<any>>} observer - An object with \"next\", \"error\", and \"complete\" functions, following the observer pattern.\n   * @returns {Subscription} A Subscription object on which you can call \".unsubscribe()\" to stop listening to descriptors.\n   * @example\n  const sub = TransportFoo.listen({\n  next: e => {\n    if (e.type===\"add\") {\n      sub.unsubscribe();\n      const transport = await TransportFoo.open(e.descriptor);\n      ...\n    }\n  },\n  error: error => {},\n  complete: () => {}\n  })\n   */\n  static readonly listen: (observer: Observer<DescriptorEvent<any>>) => Subscription;\n\n  /**\n   * Attempt to create a Transport instance with a specific descriptor.\n   * @param {any} descriptor - The descriptor to open the transport with.\n   * @param {number} timeout - An optional timeout for the transport connection.\n   * @param {TraceContext} context Optional tracing/log context\n   * @returns {Promise<Transport>} A promise that resolves with a Transport instance.\n   * @example\n  TransportFoo.open(descriptor).then(transport => ...)\n   */\n  static readonly open: (\n    descriptor?: any,\n    timeoutMs?: number,\n    context?: TraceContext,\n  ) => Promise<Transport>;\n\n  /**\n   * Send data to the device using a low level API.\n   * It's recommended to use the \"send\" method for a higher level API.\n   * @param {Buffer} apdu - The data to send.\n   * @param {Object} options - Contains optional options for the exchange function\n   *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n   */\n  exchange(\n    _apdu: Buffer,\n    { abortTimeoutMs: _abortTimeoutMs }: { abortTimeoutMs?: number } = {},\n  ): Promise<Buffer> {\n    throw new Error(\"exchange not implemented\");\n  }\n\n  /**\n   * Send apdus in batch to the device using a low level API.\n   * The default implementation is to call exchange for each apdu.\n   * @param {Array<Buffer>} apdus - array of apdus to send.\n   * @param {Observer<Buffer>} observer - an observer that will receive the response of each apdu.\n   * @returns {Subscription} A Subscription object on which you can call \".unsubscribe()\" to stop sending apdus.\n   */\n  exchangeBulk(apdus: Buffer[], observer: Observer<Buffer>): Subscription {\n    let unsubscribed = false;\n    const unsubscribe = () => {\n      unsubscribed = true;\n    };\n\n    const main = async () => {\n      if (unsubscribed) return;\n      for (const apdu of apdus) {\n        const r = await this.exchange(apdu);\n        if (unsubscribed) return;\n        const status = r.readUInt16BE(r.length - 2);\n        if (status !== StatusCodes.OK) {\n          throw new TransportStatusError(status);\n        }\n        observer.next(r);\n      }\n    };\n\n    main().then(\n      () => !unsubscribed && observer.complete(),\n      e => !unsubscribed && observer.error(e),\n    );\n\n    return { unsubscribe };\n  }\n\n  /**\n   * Set the \"scramble key\" for the next data exchanges with the device.\n   * Each app can have a different scramble key and it is set internally during instantiation.\n   * @param {string} key - The scramble key to set.\n   * deprecated This method is no longer needed for modern transports and should be migrated away from.\n   * no @ before deprecated as it breaks documentationjs on version 14.0.2\n   * https://github.com/documentationjs/documentation/issues/1596\n   */\n  setScrambleKey(_key: string) {}\n\n  /**\n   * Close the connection with the device.\n   *\n   * Note: for certain transports (hw-transport-node-hid-singleton for ex), once the promise resolved,\n   * the transport instance is actually still cached, and the device is disconnected only after a defined timeout.\n   * But for the consumer of the Transport, this does not matter and it can consider the transport to be closed.\n   *\n   * @returns {Promise<void>} A promise that resolves when the transport is closed.\n   */\n  close(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  _events = new EventEmitter();\n\n  /**\n   * Listen for an event on the transport instance.\n   * Transport implementations may have specific events. Common events include:\n   * \"disconnect\" : triggered when the transport is disconnected.\n   * @param {string} eventName - The name of the event to listen for.\n   * @param {(...args: Array<any>) => any} cb - The callback function to be invoked when the event occurs.\n   */\n  on(eventName: string, cb: (...args: Array<any>) => any): void {\n    this._events.on(eventName, cb);\n  }\n\n  /**\n   * Stop listening to an event on an instance of transport.\n   */\n  off(eventName: string, cb: (...args: Array<any>) => any): void {\n    this._events.removeListener(eventName, cb);\n  }\n\n  emit(event: string, ...args: any): void {\n    this._events.emit(event, ...args);\n  }\n\n  /**\n   * Enable or not logs of the binary exchange\n   */\n  setDebugMode() {\n    console.warn(\n      \"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\",\n    );\n  }\n\n  /**\n   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n   */\n  setExchangeTimeout(exchangeTimeout: number): void {\n    this.exchangeTimeout = exchangeTimeout;\n  }\n\n  /**\n   * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n   */\n  setExchangeUnresponsiveTimeout(unresponsiveTimeout: number): void {\n    this.unresponsiveTimeout = unresponsiveTimeout;\n  }\n\n  /**\n   * Send data to the device using the higher level API.\n   *\n   * @param {number} cla - The instruction class for the command.\n   * @param {number} ins - The instruction code for the command.\n   * @param {number} p1 - The first parameter for the instruction.\n   * @param {number} p2 - The second parameter for the instruction.\n   * @param {Buffer} data - The data to be sent. Defaults to an empty buffer.\n   * @param {Array<number>} statusList - A list of acceptable status codes for the response. Defaults to [StatusCodes.OK].\n   * @param {Object} options - Contains optional options for the exchange function\n   *  - abortTimeoutMs: stop the send after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n   */\n  send = async (\n    cla: number,\n    ins: number,\n    p1: number,\n    p2: number,\n    data: Buffer = Buffer.alloc(0),\n    statusList: Array<number> = [StatusCodes.OK],\n    { abortTimeoutMs }: { abortTimeoutMs?: number } = {},\n  ): Promise<Buffer> => {\n    const tracer = this.tracer.withUpdatedContext({ function: \"send\" });\n\n    if (data.length >= 256) {\n      tracer.trace(\"data.length exceeded 256 bytes limit\", { dataLength: data.length });\n      throw new TransportError(\n        \"data.length exceed 256 bytes limit. Got: \" + data.length,\n        \"DataLengthTooBig\",\n      );\n    }\n\n    tracer.trace(\"Starting an exchange\", { abortTimeoutMs });\n    const response = await this.exchange(\n      // The size of the data is added in 1 byte just before `data`\n      Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]),\n      { abortTimeoutMs },\n    );\n    tracer.trace(\"Received response from exchange\");\n    const sw = response.readUInt16BE(response.length - 2);\n\n    if (!statusList.some(s => s === sw)) {\n      throw new TransportStatusError(sw);\n    }\n\n    return response;\n  };\n\n  /**\n   * create() allows to open the first descriptor available or\n   * throw if there is none or if timeout is reached.\n   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n   * @example\n  TransportFoo.create().then(transport => ...)\n   */\n  static create(openTimeout = 3000, listenTimeout?: number): Promise<Transport> {\n    return new Promise((resolve, reject) => {\n      let found = false;\n      const sub = this.listen({\n        next: e => {\n          found = true;\n          if (sub) sub.unsubscribe();\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          this.open(e.descriptor, openTimeout).then(resolve, reject);\n        },\n        error: e => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          reject(e);\n        },\n        complete: () => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n\n          if (!found) {\n            reject(new TransportError(this.ErrorMessage_NoDeviceFound, \"NoDeviceFound\"));\n          }\n        },\n      });\n      const listenTimeoutId = listenTimeout\n        ? setTimeout(() => {\n            sub.unsubscribe();\n            reject(new TransportError(this.ErrorMessage_ListenTimeout, \"ListenTimeout\"));\n          }, listenTimeout)\n        : null;\n    });\n  }\n\n  // Blocks other exchange to happen concurrently\n  exchangeBusyPromise: Promise<void> | null | undefined;\n\n  /**\n   * Wrapper to make an exchange \"atomic\" (blocking any other exchange)\n   *\n   * It also handles \"unresponsiveness\" by emitting \"unresponsive\" and \"responsive\" events.\n   *\n   * @param f The exchange job, using the transport to run\n   * @returns a Promise resolving with the output of the given job\n   */\n  async exchangeAtomicImpl<Output>(f: () => Promise<Output>): Promise<Output> {\n    const tracer = this.tracer.withUpdatedContext({\n      function: \"exchangeAtomicImpl\",\n      unresponsiveTimeout: this.unresponsiveTimeout,\n    });\n\n    if (this.exchangeBusyPromise) {\n      tracer.trace(\"Atomic exchange is already busy\");\n      throw new TransportRaceCondition(\n        \"An action was already pending on the Ledger device. Please deny or reconnect.\",\n      );\n    }\n\n    // Sets the atomic guard\n    let resolveBusy;\n    const busyPromise: Promise<void> = new Promise(r => {\n      resolveBusy = r;\n    });\n    this.exchangeBusyPromise = busyPromise;\n\n    // The device unresponsiveness handler\n    let unresponsiveReached = false;\n    const timeout = setTimeout(() => {\n      tracer.trace(`Timeout reached, emitting Transport event \"unresponsive\"`, {\n        unresponsiveTimeout: this.unresponsiveTimeout,\n      });\n      unresponsiveReached = true;\n      this.emit(\"unresponsive\");\n    }, this.unresponsiveTimeout);\n\n    try {\n      const res = await f();\n\n      if (unresponsiveReached) {\n        tracer.trace(\"Device was unresponsive, emitting responsive\");\n        this.emit(\"responsive\");\n      }\n\n      return res;\n    } finally {\n      tracer.trace(\"Finalize, clearing busy guard\");\n\n      clearTimeout(timeout);\n      if (resolveBusy) resolveBusy();\n      this.exchangeBusyPromise = null;\n    }\n  }\n\n  decorateAppAPIMethods(self: Record<string, any>, methods: Array<string>, scrambleKey: string) {\n    for (const methodName of methods) {\n      self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);\n    }\n  }\n\n  _appAPIlock: string | null = null;\n\n  decorateAppAPIMethod<R, A extends any[]>(\n    methodName: string,\n    f: (...args: A) => Promise<R>,\n    ctx: any,\n    scrambleKey: string,\n  ): (...args: A) => Promise<R> {\n    return async (...args) => {\n      const { _appAPIlock } = this;\n\n      if (_appAPIlock) {\n        return Promise.reject(\n          new TransportError(\"Ledger Device is busy (lock \" + _appAPIlock + \")\", \"TransportLocked\"),\n        );\n      }\n\n      try {\n        this._appAPIlock = methodName;\n        this.setScrambleKey(scrambleKey);\n        return await f.apply(ctx, args);\n      } finally {\n        this._appAPIlock = null;\n      }\n    };\n  }\n\n  /**\n   * Sets the context used by the logging/tracing mechanism\n   *\n   * Useful when re-using (cached) the same Transport instance,\n   * but with a new tracing context.\n   *\n   * @param context A TraceContext, that can undefined to reset the context\n   */\n  setTraceContext(context?: TraceContext) {\n    this.tracer = this.tracer.withContext(context);\n  }\n\n  /**\n   * Updates the context used by the logging/tracing mechanism\n   *\n   * The update only overrides the key-value that are already defined in the current context.\n   *\n   * @param contextToAdd A TraceContext that will be added to the current context\n   */\n  updateTraceContext(contextToAdd: TraceContext) {\n    this.tracer.updateContext(contextToAdd);\n  }\n\n  /**\n   * Gets the tracing context of the transport instance\n   */\n  getTraceContext(): TraceContext | undefined {\n    return this.tracer.getContext();\n  }\n\n  static ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\n  static ErrorMessage_NoDeviceFound = \"No Ledger device found\";\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}