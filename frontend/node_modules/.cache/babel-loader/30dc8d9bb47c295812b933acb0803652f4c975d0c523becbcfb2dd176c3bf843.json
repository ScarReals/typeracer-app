{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TrezorConnectDynamic = void 0;\nconst utils_1 = require(\"@trezor/utils\");\nconst constants_1 = require(\"../constants\");\nconst events_1 = require(\"../events\");\nconst proxy_event_emitter_1 = require(\"../utils/proxy-event-emitter\");\nclass TrezorConnectDynamic {\n  eventEmitter;\n  currentTarget;\n  implementations;\n  getInitTarget;\n  handleBeforeCall;\n  handleErrorFallback;\n  lastSettings;\n  callPending = 0;\n  beforeCallSynchronize = (0, utils_1.getSynchronize)();\n  constructor({\n    implementations,\n    getInitTarget,\n    handleBeforeCall,\n    handleErrorFallback\n  }) {\n    this.implementations = implementations;\n    this.currentTarget = this.implementations[0].type;\n    this.getInitTarget = getInitTarget;\n    this.handleBeforeCall = handleBeforeCall;\n    this.handleErrorFallback = handleErrorFallback;\n    this.eventEmitter = new proxy_event_emitter_1.ProxyEventEmitter(this.implementations.map(impl => impl.impl.eventEmitter));\n  }\n  getTarget() {\n    return this.implementations.find(impl => impl.type === this.currentTarget).impl;\n  }\n  getTargetType() {\n    return this.currentTarget;\n  }\n  async switchTarget(target) {\n    if (this.currentTarget === target) {\n      return;\n    }\n    if (!this.lastSettings) {\n      throw constants_1.ERRORS.TypedError('Init_ManifestMissing');\n    }\n    const oldTargetType = this.getTargetType();\n    const oldTarget = this.getTarget();\n    try {\n      this.currentTarget = target;\n      await this.getTarget().init(this.lastSettings);\n      await oldTarget.dispose();\n    } catch {\n      this.currentTarget = oldTargetType;\n    }\n  }\n  manifest(manifest) {\n    this.lastSettings = {\n      ...this.lastSettings,\n      manifest\n    };\n    this.getTarget().manifest(manifest);\n  }\n  async init(settings) {\n    if (!settings?.manifest) {\n      throw constants_1.ERRORS.TypedError('Init_ManifestMissing');\n    }\n    this.lastSettings = settings;\n    this.currentTarget = this.getInitTarget(settings);\n    this.callPending = 0;\n    try {\n      return await this.getTarget().init(this.lastSettings);\n    } catch (error) {\n      if (await this.handleErrorFallback(error.code)) {\n        return;\n      }\n      throw error;\n    }\n  }\n  setTransports({\n    transports\n  }) {\n    this.lastSettings = {\n      ...this.lastSettings,\n      transports\n    };\n    this.getTarget().setTransports({\n      transports\n    });\n  }\n  async call(params) {\n    try {\n      if (this.callPending === 0) {\n        await this.beforeCallSynchronize(async () => {\n          this.callPending++;\n          await this.handleBeforeCall();\n        });\n      }\n      const response = await this.getTarget().call(params);\n      if (!response.success) {\n        if (await this.handleErrorFallback(response.payload.code)) {\n          return await this.getTarget().call(params);\n        }\n      }\n      return response;\n    } catch (error) {\n      return (0, events_1.createErrorMessage)(error);\n    } finally {\n      this.callPending--;\n    }\n  }\n  requestLogin(params) {\n    return this.getTarget().requestLogin(params);\n  }\n  uiResponse(params) {\n    return this.getTarget().uiResponse(params);\n  }\n  cancel(error) {\n    return this.getTarget().cancel(error);\n  }\n  dispose() {\n    this.eventEmitter.removeAllListeners();\n    this.callPending = 0;\n    return this.getTarget().dispose();\n  }\n}\nexports.TrezorConnectDynamic = TrezorConnectDynamic;","map":{"version":3,"names":["Object","defineProperty","exports","value","TrezorConnectDynamic","utils_1","require","constants_1","events_1","proxy_event_emitter_1","eventEmitter","currentTarget","implementations","getInitTarget","handleBeforeCall","handleErrorFallback","lastSettings","callPending","beforeCallSynchronize","getSynchronize","constructor","type","ProxyEventEmitter","map","impl","getTarget","find","getTargetType","switchTarget","target","ERRORS","TypedError","oldTargetType","oldTarget","init","dispose","manifest","settings","error","code","setTransports","transports","call","params","response","success","payload","createErrorMessage","requestLogin","uiResponse","cancel","removeAllListeners"],"sources":["/home/kokoi/typeracer-app/frontend/node_modules/@trezor/connect/lib/impl/dynamic.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TrezorConnectDynamic = void 0;\nconst utils_1 = require(\"@trezor/utils\");\nconst constants_1 = require(\"../constants\");\nconst events_1 = require(\"../events\");\nconst proxy_event_emitter_1 = require(\"../utils/proxy-event-emitter\");\nclass TrezorConnectDynamic {\n    eventEmitter;\n    currentTarget;\n    implementations;\n    getInitTarget;\n    handleBeforeCall;\n    handleErrorFallback;\n    lastSettings;\n    callPending = 0;\n    beforeCallSynchronize = (0, utils_1.getSynchronize)();\n    constructor({ implementations, getInitTarget, handleBeforeCall, handleErrorFallback, }) {\n        this.implementations = implementations;\n        this.currentTarget = this.implementations[0].type;\n        this.getInitTarget = getInitTarget;\n        this.handleBeforeCall = handleBeforeCall;\n        this.handleErrorFallback = handleErrorFallback;\n        this.eventEmitter = new proxy_event_emitter_1.ProxyEventEmitter(this.implementations.map(impl => impl.impl.eventEmitter));\n    }\n    getTarget() {\n        return this.implementations.find(impl => impl.type === this.currentTarget).impl;\n    }\n    getTargetType() {\n        return this.currentTarget;\n    }\n    async switchTarget(target) {\n        if (this.currentTarget === target) {\n            return;\n        }\n        if (!this.lastSettings) {\n            throw constants_1.ERRORS.TypedError('Init_ManifestMissing');\n        }\n        const oldTargetType = this.getTargetType();\n        const oldTarget = this.getTarget();\n        try {\n            this.currentTarget = target;\n            await this.getTarget().init(this.lastSettings);\n            await oldTarget.dispose();\n        }\n        catch {\n            this.currentTarget = oldTargetType;\n        }\n    }\n    manifest(manifest) {\n        this.lastSettings = { ...this.lastSettings, manifest };\n        this.getTarget().manifest(manifest);\n    }\n    async init(settings) {\n        if (!settings?.manifest) {\n            throw constants_1.ERRORS.TypedError('Init_ManifestMissing');\n        }\n        this.lastSettings = settings;\n        this.currentTarget = this.getInitTarget(settings);\n        this.callPending = 0;\n        try {\n            return await this.getTarget().init(this.lastSettings);\n        }\n        catch (error) {\n            if (await this.handleErrorFallback(error.code)) {\n                return;\n            }\n            throw error;\n        }\n    }\n    setTransports({ transports }) {\n        this.lastSettings = { ...this.lastSettings, transports };\n        this.getTarget().setTransports({ transports });\n    }\n    async call(params) {\n        try {\n            if (this.callPending === 0) {\n                await this.beforeCallSynchronize(async () => {\n                    this.callPending++;\n                    await this.handleBeforeCall();\n                });\n            }\n            const response = await this.getTarget().call(params);\n            if (!response.success) {\n                if (await this.handleErrorFallback(response.payload.code)) {\n                    return await this.getTarget().call(params);\n                }\n            }\n            return response;\n        }\n        catch (error) {\n            return (0, events_1.createErrorMessage)(error);\n        }\n        finally {\n            this.callPending--;\n        }\n    }\n    requestLogin(params) {\n        return this.getTarget().requestLogin(params);\n    }\n    uiResponse(params) {\n        return this.getTarget().uiResponse(params);\n    }\n    cancel(error) {\n        return this.getTarget().cancel(error);\n    }\n    dispose() {\n        this.eventEmitter.removeAllListeners();\n        this.callPending = 0;\n        return this.getTarget().dispose();\n    }\n}\nexports.TrezorConnectDynamic = TrezorConnectDynamic;\n//# sourceMappingURL=dynamic.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}