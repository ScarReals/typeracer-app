{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.montgomery = montgomery;\n/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst utils_ts_1 = require(\"../utils.js\");\nconst modular_ts_1 = require(\"./modular.js\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nfunction validateOpts(curve) {\n  (0, utils_ts_1._validateObject)(curve, {\n    adjustScalarBytes: 'function',\n    powPminus2: 'function'\n  });\n  return Object.freeze({\n    ...curve\n  });\n}\nfunction montgomery(curveDef) {\n  const CURVE = validateOpts(curveDef);\n  const {\n    P,\n    type,\n    adjustScalarBytes,\n    powPminus2,\n    randomBytes: rand\n  } = CURVE;\n  const is25519 = type === 'x25519';\n  if (!is25519 && type !== 'x448') throw new Error('invalid type');\n  const randomBytes_ = rand || utils_ts_1.randomBytes;\n  const montgomeryBits = is25519 ? 255 : 448;\n  const fieldLen = is25519 ? 32 : 56;\n  const Gu = is25519 ? BigInt(9) : BigInt(5);\n  // RFC 7748 #5:\n  // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and\n  // (156326 - 2) / 4 = 39081 for curve448/X448\n  // const a = is25519 ? 156326n : 486662n;\n  const a24 = is25519 ? BigInt(121665) : BigInt(39081);\n  // RFC: x25519 \"the resulting integer is of the form 2^254 plus\n  // eight times a value between 0 and 2^251 - 1 (inclusive)\"\n  // x448: \"2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)\"\n  const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);\n  const maxAdded = is25519 ? BigInt(8) * _2n ** BigInt(251) - _1n : BigInt(4) * _2n ** BigInt(445) - _1n;\n  const maxScalar = minScalar + maxAdded + _1n; // (inclusive)\n  const modP = n => (0, modular_ts_1.mod)(n, P);\n  const GuBytes = encodeU(Gu);\n  function encodeU(u) {\n    return (0, utils_ts_1.numberToBytesLE)(modP(u), fieldLen);\n  }\n  function decodeU(u) {\n    const _u = (0, utils_ts_1.ensureBytes)('u coordinate', u, fieldLen);\n    // RFC: When receiving such an array, implementations of X25519\n    // (but not X448) MUST mask the most significant bit in the final byte.\n    if (is25519) _u[31] &= 127; // 0b0111_1111\n    // RFC: Implementations MUST accept non-canonical values and process them as\n    // if they had been reduced modulo the field prime.  The non-canonical\n    // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224\n    // - 1 through 2^448 - 1 for X448.\n    return modP((0, utils_ts_1.bytesToNumberLE)(_u));\n  }\n  function decodeScalar(scalar) {\n    return (0, utils_ts_1.bytesToNumberLE)(adjustScalarBytes((0, utils_ts_1.ensureBytes)('scalar', scalar, fieldLen)));\n  }\n  function scalarMult(scalar, u) {\n    const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));\n    // Some public keys are useless, of low-order. Curve author doesn't think\n    // it needs to be validated, but we do it nonetheless.\n    // https://cr.yp.to/ecdh.html#validate\n    if (pu === _0n) throw new Error('invalid private or public key received');\n    return encodeU(pu);\n  }\n  // Computes public key from private. By doing scalar multiplication of base point.\n  function scalarMultBase(scalar) {\n    return scalarMult(scalar, GuBytes);\n  }\n  // cswap from RFC7748 \"example code\"\n  function cswap(swap, x_2, x_3) {\n    // dummy = mask(swap) AND (x_2 XOR x_3)\n    // Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n    // and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    const dummy = modP(swap * (x_2 - x_3));\n    x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy\n    x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy\n    return {\n      x_2,\n      x_3\n    };\n  }\n  /**\n   * Montgomery x-only multiplication ladder.\n   * @param pointU u coordinate (x) on Montgomery Curve 25519\n   * @param scalar by which the point would be multiplied\n   * @returns new Point on Montgomery curve\n   */\n  function montgomeryLadder(u, scalar) {\n    (0, utils_ts_1.aInRange)('u', u, _0n, P);\n    (0, utils_ts_1.aInRange)('scalar', scalar, minScalar, maxScalar);\n    const k = scalar;\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n      const k_t = k >> t & _1n;\n      swap ^= k_t;\n      ({\n        x_2,\n        x_3\n      } = cswap(swap, x_2, x_3));\n      ({\n        x_2: z_2,\n        x_3: z_3\n      } = cswap(swap, z_2, z_3));\n      swap = k_t;\n      const A = x_2 + z_2;\n      const AA = modP(A * A);\n      const B = x_2 - z_2;\n      const BB = modP(B * B);\n      const E = AA - BB;\n      const C = x_3 + z_3;\n      const D = x_3 - z_3;\n      const DA = modP(D * A);\n      const CB = modP(C * B);\n      const dacb = DA + CB;\n      const da_cb = DA - CB;\n      x_3 = modP(dacb * dacb);\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\n      x_2 = modP(AA * BB);\n      z_2 = modP(E * (AA + modP(a24 * E)));\n    }\n    ({\n      x_2,\n      x_3\n    } = cswap(swap, x_2, x_3));\n    ({\n      x_2: z_2,\n      x_3: z_3\n    } = cswap(swap, z_2, z_3));\n    const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent\n    return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))\n  }\n  return {\n    scalarMult,\n    scalarMultBase,\n    getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),\n    getPublicKey: privateKey => scalarMultBase(privateKey),\n    utils: {\n      randomPrivateKey: () => randomBytes_(fieldLen)\n    },\n    GuBytes: GuBytes.slice()\n  };\n}","map":{"version":3,"names":["exports","montgomery","utils_ts_1","require","modular_ts_1","_0n","BigInt","_1n","_2n","validateOpts","curve","_validateObject","adjustScalarBytes","powPminus2","Object","freeze","curveDef","CURVE","P","type","randomBytes","rand","is25519","Error","randomBytes_","montgomeryBits","fieldLen","Gu","a24","minScalar","maxAdded","maxScalar","modP","n","mod","GuBytes","encodeU","u","numberToBytesLE","decodeU","_u","ensureBytes","bytesToNumberLE","decodeScalar","scalar","scalarMult","pu","montgomeryLadder","scalarMultBase","cswap","swap","x_2","x_3","dummy","aInRange","k","x_1","z_2","z_3","t","k_t","A","AA","B","BB","E","C","D","DA","CB","dacb","da_cb","z2","getSharedSecret","privateKey","publicKey","getPublicKey","utils","randomPrivateKey","slice"],"sources":["/home/kokoi/sol-wager-app/frontend/node_modules/@noble/curves/src/abstract/montgomery.ts"],"sourcesContent":["/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  _validateObject,\n  aInRange,\n  bytesToNumberLE,\n  ensureBytes,\n  numberToBytesLE,\n  randomBytes,\n} from '../utils.ts';\nimport { mod } from './modular.ts';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\ntype Hex = string | Uint8Array;\n\nexport type CurveType = {\n  P: bigint; // finite field prime\n  type: 'x25519' | 'x448';\n  adjustScalarBytes: (bytes: Uint8Array) => Uint8Array;\n  powPminus2: (x: bigint) => bigint;\n  randomBytes?: (bytesLength?: number) => Uint8Array;\n};\n\nexport type CurveFn = {\n  scalarMult: (scalar: Hex, u: Hex) => Uint8Array;\n  scalarMultBase: (scalar: Hex) => Uint8Array;\n  getSharedSecret: (privateKeyA: Hex, publicKeyB: Hex) => Uint8Array;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  utils: { randomPrivateKey: () => Uint8Array };\n  GuBytes: Uint8Array;\n};\n\nfunction validateOpts(curve: CurveType) {\n  _validateObject(curve, {\n    adjustScalarBytes: 'function',\n    powPminus2: 'function',\n  });\n  return Object.freeze({ ...curve } as const);\n}\n\nexport function montgomery(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef);\n  const { P, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;\n  const is25519 = type === 'x25519';\n  if (!is25519 && type !== 'x448') throw new Error('invalid type');\n  const randomBytes_ = rand || randomBytes;\n\n  const montgomeryBits = is25519 ? 255 : 448;\n  const fieldLen = is25519 ? 32 : 56;\n  const Gu = is25519 ? BigInt(9) : BigInt(5);\n  // RFC 7748 #5:\n  // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and\n  // (156326 - 2) / 4 = 39081 for curve448/X448\n  // const a = is25519 ? 156326n : 486662n;\n  const a24 = is25519 ? BigInt(121665) : BigInt(39081);\n  // RFC: x25519 \"the resulting integer is of the form 2^254 plus\n  // eight times a value between 0 and 2^251 - 1 (inclusive)\"\n  // x448: \"2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)\"\n  const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);\n  const maxAdded = is25519\n    ? BigInt(8) * _2n ** BigInt(251) - _1n\n    : BigInt(4) * _2n ** BigInt(445) - _1n;\n  const maxScalar = minScalar + maxAdded + _1n; // (inclusive)\n  const modP = (n: bigint) => mod(n, P);\n  const GuBytes = encodeU(Gu);\n  function encodeU(u: bigint): Uint8Array {\n    return numberToBytesLE(modP(u), fieldLen);\n  }\n  function decodeU(u: Hex): bigint {\n    const _u = ensureBytes('u coordinate', u, fieldLen);\n    // RFC: When receiving such an array, implementations of X25519\n    // (but not X448) MUST mask the most significant bit in the final byte.\n    if (is25519) _u[31] &= 127; // 0b0111_1111\n    // RFC: Implementations MUST accept non-canonical values and process them as\n    // if they had been reduced modulo the field prime.  The non-canonical\n    // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224\n    // - 1 through 2^448 - 1 for X448.\n    return modP(bytesToNumberLE(_u));\n  }\n  function decodeScalar(scalar: Hex): bigint {\n    return bytesToNumberLE(adjustScalarBytes(ensureBytes('scalar', scalar, fieldLen)));\n  }\n  function scalarMult(scalar: Hex, u: Hex): Uint8Array {\n    const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));\n    // Some public keys are useless, of low-order. Curve author doesn't think\n    // it needs to be validated, but we do it nonetheless.\n    // https://cr.yp.to/ecdh.html#validate\n    if (pu === _0n) throw new Error('invalid private or public key received');\n    return encodeU(pu);\n  }\n  // Computes public key from private. By doing scalar multiplication of base point.\n  function scalarMultBase(scalar: Hex): Uint8Array {\n    return scalarMult(scalar, GuBytes);\n  }\n\n  // cswap from RFC7748 \"example code\"\n  function cswap(swap: bigint, x_2: bigint, x_3: bigint): { x_2: bigint; x_3: bigint } {\n    // dummy = mask(swap) AND (x_2 XOR x_3)\n    // Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n    // and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    const dummy = modP(swap * (x_2 - x_3));\n    x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy\n    x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy\n    return { x_2, x_3 };\n  }\n\n  /**\n   * Montgomery x-only multiplication ladder.\n   * @param pointU u coordinate (x) on Montgomery Curve 25519\n   * @param scalar by which the point would be multiplied\n   * @returns new Point on Montgomery curve\n   */\n  function montgomeryLadder(u: bigint, scalar: bigint): bigint {\n    aInRange('u', u, _0n, P);\n    aInRange('scalar', scalar, minScalar, maxScalar);\n    const k = scalar;\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n      const k_t = (k >> t) & _1n;\n      swap ^= k_t;\n      ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n      swap = k_t;\n\n      const A = x_2 + z_2;\n      const AA = modP(A * A);\n      const B = x_2 - z_2;\n      const BB = modP(B * B);\n      const E = AA - BB;\n      const C = x_3 + z_3;\n      const D = x_3 - z_3;\n      const DA = modP(D * A);\n      const CB = modP(C * B);\n      const dacb = DA + CB;\n      const da_cb = DA - CB;\n      x_3 = modP(dacb * dacb);\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\n      x_2 = modP(AA * BB);\n      z_2 = modP(E * (AA + modP(a24 * E)));\n    }\n    ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n    ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n    const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent\n    return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))\n  }\n\n  return {\n    scalarMult,\n    scalarMultBase,\n    getSharedSecret: (privateKey: Hex, publicKey: Hex) => scalarMult(privateKey, publicKey),\n    getPublicKey: (privateKey: Hex): Uint8Array => scalarMultBase(privateKey),\n    utils: { randomPrivateKey: () => randomBytes_(fieldLen) },\n    GuBytes: GuBytes.slice(),\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}