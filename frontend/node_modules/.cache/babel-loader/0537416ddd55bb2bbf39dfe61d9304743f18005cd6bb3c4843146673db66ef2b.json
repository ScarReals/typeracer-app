{"ast":null,"code":"import semver from \"semver\";\n/**\n * The USB product IDs will be defined as MMII, encoding a model (MM) and an interface bitfield (II)\n *\n ** Model\n * Ledger Nano S : 0x10\n * Ledger Blue : 0x00\n * Ledger Nano X : 0x40\n *\n ** Interface support bitfield\n * Generic HID : 0x01\n * Keyboard HID : 0x02\n * U2F : 0x04\n * CCID : 0x08\n * WebUSB : 0x10\n */\nexport const IIGenericHID = 0x01;\nexport const IIKeyboardHID = 0x02;\nexport const IIU2F = 0x04;\nexport const IICCID = 0x08;\nexport const IIWebUSB = 0x10;\nexport var DeviceModelId;\n(function (DeviceModelId) {\n  /** Ledger Blue */\n  DeviceModelId[\"blue\"] = \"blue\";\n  /** Ledger Nano S */\n  DeviceModelId[\"nanoS\"] = \"nanoS\";\n  /** Ledger Nano S Plus */\n  DeviceModelId[\"nanoSP\"] = \"nanoSP\";\n  /** Ledger Nano X */\n  DeviceModelId[\"nanoX\"] = \"nanoX\";\n  /** Ledger Stax */\n  DeviceModelId[\"stax\"] = \"stax\";\n  /** Ledger Flex (\"europa\" is the internal name) */\n  DeviceModelId[\"europa\"] = \"europa\";\n})(DeviceModelId || (DeviceModelId = {}));\nconst devices = {\n  [DeviceModelId.blue]: {\n    id: DeviceModelId.blue,\n    productName: \"Ledger Blue\",\n    productIdMM: 0x00,\n    legacyUsbProductId: 0x0000,\n    usbOnly: true,\n    memorySize: 480 * 1024,\n    masks: [0x31000000, 0x31010000],\n    getBlockSize: _firwareVersion => 4 * 1024\n  },\n  [DeviceModelId.nanoS]: {\n    id: DeviceModelId.nanoS,\n    productName: \"Ledger Nano S\",\n    productIdMM: 0x10,\n    legacyUsbProductId: 0x0001,\n    usbOnly: true,\n    memorySize: 320 * 1024,\n    masks: [0x31100000],\n    getBlockSize: firmwareVersion => semver.lt(semver.coerce(firmwareVersion) ?? \"\", \"2.0.0\") ? 4 * 1024 : 2 * 1024\n  },\n  [DeviceModelId.nanoX]: {\n    id: DeviceModelId.nanoX,\n    productName: \"Ledger Nano X\",\n    productIdMM: 0x40,\n    legacyUsbProductId: 0x0004,\n    usbOnly: false,\n    memorySize: 2 * 1024 * 1024,\n    masks: [0x33000000],\n    getBlockSize: _firwareVersion => 4 * 1024,\n    bluetoothSpec: [{\n      serviceUuid: \"13d63400-2c97-0004-0000-4c6564676572\",\n      notifyUuid: \"13d63400-2c97-0004-0001-4c6564676572\",\n      writeUuid: \"13d63400-2c97-0004-0002-4c6564676572\",\n      writeCmdUuid: \"13d63400-2c97-0004-0003-4c6564676572\"\n    }]\n  },\n  [DeviceModelId.nanoSP]: {\n    id: DeviceModelId.nanoSP,\n    productName: \"Ledger Nano S Plus\",\n    productIdMM: 0x50,\n    legacyUsbProductId: 0x0005,\n    usbOnly: true,\n    memorySize: 1533 * 1024,\n    masks: [0x33100000],\n    getBlockSize: _firmwareVersion => 32\n  },\n  [DeviceModelId.stax]: {\n    id: DeviceModelId.stax,\n    productName: \"Ledger Stax\",\n    productIdMM: 0x60,\n    legacyUsbProductId: 0x0006,\n    usbOnly: false,\n    memorySize: 1533 * 1024,\n    masks: [0x33200000],\n    getBlockSize: _firmwareVersion => 32,\n    bluetoothSpec: [{\n      serviceUuid: \"13d63400-2c97-6004-0000-4c6564676572\",\n      notifyUuid: \"13d63400-2c97-6004-0001-4c6564676572\",\n      writeUuid: \"13d63400-2c97-6004-0002-4c6564676572\",\n      writeCmdUuid: \"13d63400-2c97-6004-0003-4c6564676572\"\n    }]\n  },\n  [DeviceModelId.europa]: {\n    id: DeviceModelId.europa,\n    productName: \"Ledger Flex\",\n    productIdMM: 0x70,\n    legacyUsbProductId: 0x0007,\n    usbOnly: false,\n    memorySize: 1533 * 1024,\n    masks: [0x33300000],\n    getBlockSize: _firmwareVersion => 32,\n    bluetoothSpec: [{\n      serviceUuid: \"13d63400-2c97-3004-0000-4c6564676572\",\n      notifyUuid: \"13d63400-2c97-3004-0001-4c6564676572\",\n      writeUuid: \"13d63400-2c97-3004-0002-4c6564676572\",\n      writeCmdUuid: \"13d63400-2c97-3004-0003-4c6564676572\"\n    }]\n  }\n};\nconst productMap = {\n  Blue: DeviceModelId.blue,\n  \"Nano S\": DeviceModelId.nanoS,\n  \"Nano S Plus\": DeviceModelId.nanoSP,\n  \"Nano X\": DeviceModelId.nanoX,\n  Stax: DeviceModelId.stax,\n  Europa: DeviceModelId.europa\n};\nconst devicesList = Object.values(devices);\n/**\n *\n */\nexport const ledgerUSBVendorId = 0x2c97;\n/**\n *\n */\nexport const getDeviceModel = id => {\n  const info = devices[id];\n  if (!info) throw new Error(\"device '\" + id + \"' does not exist\");\n  return info;\n};\n/**\n * Given a `targetId`, return the deviceModel associated to it,\n * based on the first two bytes.\n */\nexport const identifyTargetId = targetId => {\n  const deviceModel = devicesList.find(({\n    masks\n  }) => masks.find(mask => (targetId & 0xffff0000) === mask));\n  return deviceModel;\n};\n/**\n * From a given USB product id, return the deviceModel associated to it.\n *\n * The mapping from the product id is only based on the 2 most significant bytes.\n * For example, Stax is defined with a product id of 0x60ii, a product id 0x6011 would be mapped to it.\n */\nexport const identifyUSBProductId = usbProductId => {\n  const legacy = devicesList.find(d => d.legacyUsbProductId === usbProductId);\n  if (legacy) return legacy;\n  const mm = usbProductId >> 8;\n  const deviceModel = devicesList.find(d => d.productIdMM === mm);\n  return deviceModel;\n};\nexport const identifyProductName = productName => {\n  const deviceModel = devicesList.find(d => d.id === productMap[productName]);\n  return deviceModel;\n};\nconst bluetoothServices = [];\nconst serviceUuidToInfos = {};\nfor (const id in devices) {\n  const deviceModel = devices[id];\n  const {\n    bluetoothSpec\n  } = deviceModel;\n  if (bluetoothSpec) {\n    for (let i = 0; i < bluetoothSpec.length; i++) {\n      const spec = bluetoothSpec[i];\n      bluetoothServices.push(spec.serviceUuid);\n      serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[spec.serviceUuid.replace(/-/g, \"\")] = {\n        deviceModel,\n        ...spec\n      };\n    }\n  }\n}\n/**\n *\n */\nexport const getBluetoothServiceUuids = () => bluetoothServices;\n/**\n *\n */\nexport const getInfosForServiceUuid = uuid => serviceUuidToInfos[uuid.toLowerCase()];","map":{"version":3,"names":["semver","IIGenericHID","IIKeyboardHID","IIU2F","IICCID","IIWebUSB","DeviceModelId","devices","blue","id","productName","productIdMM","legacyUsbProductId","usbOnly","memorySize","masks","getBlockSize","_firwareVersion","nanoS","firmwareVersion","lt","coerce","nanoX","bluetoothSpec","serviceUuid","notifyUuid","writeUuid","writeCmdUuid","nanoSP","_firmwareVersion","stax","europa","productMap","Blue","Stax","Europa","devicesList","Object","values","ledgerUSBVendorId","getDeviceModel","info","Error","identifyTargetId","targetId","deviceModel","find","mask","identifyUSBProductId","usbProductId","legacy","d","mm","identifyProductName","bluetoothServices","serviceUuidToInfos","i","length","spec","push","replace","getBluetoothServiceUuids","getInfosForServiceUuid","uuid","toLowerCase"],"sources":["/home/kokoi/sol-wager-app/frontend/node_modules/@ledgerhq/devices/src/index.ts"],"sourcesContent":["import semver from \"semver\";\n\n/**\n * The USB product IDs will be defined as MMII, encoding a model (MM) and an interface bitfield (II)\n *\n ** Model\n * Ledger Nano S : 0x10\n * Ledger Blue : 0x00\n * Ledger Nano X : 0x40\n *\n ** Interface support bitfield\n * Generic HID : 0x01\n * Keyboard HID : 0x02\n * U2F : 0x04\n * CCID : 0x08\n * WebUSB : 0x10\n */\nexport const IIGenericHID = 0x01;\nexport const IIKeyboardHID = 0x02;\nexport const IIU2F = 0x04;\nexport const IICCID = 0x08;\nexport const IIWebUSB = 0x10;\n\nexport enum DeviceModelId {\n  /** Ledger Blue */\n  blue = \"blue\",\n  /** Ledger Nano S */\n  nanoS = \"nanoS\",\n  /** Ledger Nano S Plus */\n  nanoSP = \"nanoSP\",\n  /** Ledger Nano X */\n  nanoX = \"nanoX\",\n  /** Ledger Stax */\n  stax = \"stax\",\n  /** Ledger Flex (\"europa\" is the internal name) */\n  europa = \"europa\", // DO NOT CHANGE TO FLEX or handle all migration issues, things will break\n}\n\nconst devices: { [key in DeviceModelId]: DeviceModel } = {\n  [DeviceModelId.blue]: {\n    id: DeviceModelId.blue,\n    productName: \"Ledger Blue\",\n    productIdMM: 0x00,\n    legacyUsbProductId: 0x0000,\n    usbOnly: true,\n    memorySize: 480 * 1024,\n    masks: [0x31000000, 0x31010000],\n    getBlockSize: (_firwareVersion: string): number => 4 * 1024,\n  },\n  [DeviceModelId.nanoS]: {\n    id: DeviceModelId.nanoS,\n    productName: \"Ledger Nano S\",\n    productIdMM: 0x10,\n    legacyUsbProductId: 0x0001,\n    usbOnly: true,\n    memorySize: 320 * 1024,\n    masks: [0x31100000],\n    getBlockSize: (firmwareVersion: string): number =>\n      semver.lt(semver.coerce(firmwareVersion) ?? \"\", \"2.0.0\") ? 4 * 1024 : 2 * 1024,\n  },\n  [DeviceModelId.nanoX]: {\n    id: DeviceModelId.nanoX,\n    productName: \"Ledger Nano X\",\n    productIdMM: 0x40,\n    legacyUsbProductId: 0x0004,\n    usbOnly: false,\n    memorySize: 2 * 1024 * 1024,\n    masks: [0x33000000],\n    getBlockSize: (_firwareVersion: string): number => 4 * 1024,\n    bluetoothSpec: [\n      {\n        serviceUuid: \"13d63400-2c97-0004-0000-4c6564676572\",\n        notifyUuid: \"13d63400-2c97-0004-0001-4c6564676572\",\n        writeUuid: \"13d63400-2c97-0004-0002-4c6564676572\",\n        writeCmdUuid: \"13d63400-2c97-0004-0003-4c6564676572\",\n      },\n    ],\n  },\n  [DeviceModelId.nanoSP]: {\n    id: DeviceModelId.nanoSP,\n    productName: \"Ledger Nano S Plus\",\n    productIdMM: 0x50,\n    legacyUsbProductId: 0x0005,\n    usbOnly: true,\n    memorySize: 1533 * 1024,\n    masks: [0x33100000],\n    getBlockSize: (_firmwareVersion: string): number => 32,\n  },\n  [DeviceModelId.stax]: {\n    id: DeviceModelId.stax,\n    productName: \"Ledger Stax\",\n    productIdMM: 0x60,\n    legacyUsbProductId: 0x0006,\n    usbOnly: false,\n    memorySize: 1533 * 1024,\n    masks: [0x33200000],\n    getBlockSize: (_firmwareVersion: string): number => 32,\n    bluetoothSpec: [\n      {\n        serviceUuid: \"13d63400-2c97-6004-0000-4c6564676572\",\n        notifyUuid: \"13d63400-2c97-6004-0001-4c6564676572\",\n        writeUuid: \"13d63400-2c97-6004-0002-4c6564676572\",\n        writeCmdUuid: \"13d63400-2c97-6004-0003-4c6564676572\",\n      },\n    ],\n  },\n  [DeviceModelId.europa]: {\n    id: DeviceModelId.europa,\n    productName: \"Ledger Flex\",\n    productIdMM: 0x70,\n    legacyUsbProductId: 0x0007,\n    usbOnly: false,\n    memorySize: 1533 * 1024,\n    masks: [0x33300000],\n    getBlockSize: (_firmwareVersion: string): number => 32,\n    bluetoothSpec: [\n      {\n        serviceUuid: \"13d63400-2c97-3004-0000-4c6564676572\",\n        notifyUuid: \"13d63400-2c97-3004-0001-4c6564676572\",\n        writeUuid: \"13d63400-2c97-3004-0002-4c6564676572\",\n        writeCmdUuid: \"13d63400-2c97-3004-0003-4c6564676572\",\n      },\n    ],\n  },\n};\n\nconst productMap = {\n  Blue: DeviceModelId.blue,\n  \"Nano S\": DeviceModelId.nanoS,\n  \"Nano S Plus\": DeviceModelId.nanoSP,\n  \"Nano X\": DeviceModelId.nanoX,\n  Stax: DeviceModelId.stax,\n  Europa: DeviceModelId.europa,\n};\n\nconst devicesList: DeviceModel[] = Object.values(devices);\n\n/**\n *\n */\nexport const ledgerUSBVendorId = 0x2c97;\n\n/**\n *\n */\nexport const getDeviceModel = (id: DeviceModelId): DeviceModel => {\n  const info = devices[id];\n  if (!info) throw new Error(\"device '\" + id + \"' does not exist\");\n  return info;\n};\n\n/**\n * Given a `targetId`, return the deviceModel associated to it,\n * based on the first two bytes.\n */\nexport const identifyTargetId = (targetId: number): DeviceModel | null | undefined => {\n  const deviceModel = devicesList.find(({ masks }) =>\n    masks.find(mask => (targetId & 0xffff0000) === mask),\n  );\n\n  return deviceModel;\n};\n\n/**\n * From a given USB product id, return the deviceModel associated to it.\n *\n * The mapping from the product id is only based on the 2 most significant bytes.\n * For example, Stax is defined with a product id of 0x60ii, a product id 0x6011 would be mapped to it.\n */\nexport const identifyUSBProductId = (usbProductId: number): DeviceModel | null | undefined => {\n  const legacy = devicesList.find(d => d.legacyUsbProductId === usbProductId);\n  if (legacy) return legacy;\n  const mm = usbProductId >> 8;\n  const deviceModel = devicesList.find(d => d.productIdMM === mm);\n  return deviceModel;\n};\n\nexport const identifyProductName = (productName: string): DeviceModel | null | undefined => {\n  const deviceModel = devicesList.find(d => d.id === productMap[productName]);\n  return deviceModel;\n};\n\nconst bluetoothServices: string[] = [];\nconst serviceUuidToInfos: Record<string, BluetoothInfos> = {};\n\nfor (const id in devices) {\n  const deviceModel = devices[id];\n  const { bluetoothSpec } = deviceModel;\n  if (bluetoothSpec) {\n    for (let i = 0; i < bluetoothSpec.length; i++) {\n      const spec = bluetoothSpec[i];\n      bluetoothServices.push(spec.serviceUuid);\n      serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[\n        spec.serviceUuid.replace(/-/g, \"\")\n      ] = {\n        deviceModel,\n        ...spec,\n      };\n    }\n  }\n}\n\n/**\n *\n */\nexport const getBluetoothServiceUuids = (): string[] => bluetoothServices;\n\n/**\n *\n */\nexport const getInfosForServiceUuid = (uuid: string): BluetoothInfos | undefined =>\n  serviceUuidToInfos[uuid.toLowerCase()];\n\n/**\n *\n */\nexport interface DeviceModel {\n  id: DeviceModelId;\n  productName: string;\n  productIdMM: number;\n  legacyUsbProductId: number;\n  usbOnly: boolean;\n  memorySize: number;\n  masks: number[];\n  // blockSize: number, // THIS FIELD IS DEPRECATED, use getBlockSize\n  getBlockSize: (firmwareVersion: string) => number;\n  bluetoothSpec?: {\n    serviceUuid: string;\n    writeUuid: string;\n    writeCmdUuid: string;\n    notifyUuid: string;\n  }[];\n}\n\n/**\n *\n */\nexport interface BluetoothInfos {\n  deviceModel: DeviceModel;\n  serviceUuid: string;\n  writeUuid: string;\n  writeCmdUuid: string;\n  notifyUuid: string;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}