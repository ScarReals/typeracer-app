{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseSignInMessageSignerWalletAdapter = exports.BaseMessageSignerWalletAdapter = exports.BaseSignerWalletAdapter = void 0;\nconst adapter_js_1 = require(\"./adapter.js\");\nconst errors_js_1 = require(\"./errors.js\");\nconst transaction_js_1 = require(\"./transaction.js\");\nclass BaseSignerWalletAdapter extends adapter_js_1.BaseWalletAdapter {\n  sendTransaction(transaction_1, connection_1) {\n    return __awaiter(this, arguments, void 0, function* (transaction, connection, options = {}) {\n      let emit = true;\n      try {\n        if ((0, transaction_js_1.isVersionedTransaction)(transaction)) {\n          if (!this.supportedTransactionVersions) throw new errors_js_1.WalletSendTransactionError(`Sending versioned transactions isn't supported by this wallet`);\n          if (!this.supportedTransactionVersions.has(transaction.version)) throw new errors_js_1.WalletSendTransactionError(`Sending transaction version ${transaction.version} isn't supported by this wallet`);\n          try {\n            transaction = yield this.signTransaction(transaction);\n            const rawTransaction = transaction.serialize();\n            return yield connection.sendRawTransaction(rawTransaction, options);\n          } catch (error) {\n            // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n            if (error instanceof errors_js_1.WalletSignTransactionError) {\n              emit = false;\n              throw error;\n            }\n            throw new errors_js_1.WalletSendTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n          }\n        } else {\n          try {\n            const {\n                signers\n              } = options,\n              sendOptions = __rest(options, [\"signers\"]);\n            transaction = yield this.prepareTransaction(transaction, connection, sendOptions);\n            (signers === null || signers === void 0 ? void 0 : signers.length) && transaction.partialSign(...signers);\n            transaction = yield this.signTransaction(transaction);\n            const rawTransaction = transaction.serialize();\n            return yield connection.sendRawTransaction(rawTransaction, sendOptions);\n          } catch (error) {\n            // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n            if (error instanceof errors_js_1.WalletSignTransactionError) {\n              emit = false;\n              throw error;\n            }\n            throw new errors_js_1.WalletSendTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n          }\n        }\n      } catch (error) {\n        if (emit) {\n          this.emit('error', error);\n        }\n        throw error;\n      }\n    });\n  }\n  signAllTransactions(transactions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      for (const transaction of transactions) {\n        if ((0, transaction_js_1.isVersionedTransaction)(transaction)) {\n          if (!this.supportedTransactionVersions) throw new errors_js_1.WalletSignTransactionError(`Signing versioned transactions isn't supported by this wallet`);\n          if (!this.supportedTransactionVersions.has(transaction.version)) throw new errors_js_1.WalletSignTransactionError(`Signing transaction version ${transaction.version} isn't supported by this wallet`);\n        }\n      }\n      const signedTransactions = [];\n      for (const transaction of transactions) {\n        signedTransactions.push(yield this.signTransaction(transaction));\n      }\n      return signedTransactions;\n    });\n  }\n}\nexports.BaseSignerWalletAdapter = BaseSignerWalletAdapter;\nclass BaseMessageSignerWalletAdapter extends BaseSignerWalletAdapter {}\nexports.BaseMessageSignerWalletAdapter = BaseMessageSignerWalletAdapter;\nclass BaseSignInMessageSignerWalletAdapter extends BaseMessageSignerWalletAdapter {}\nexports.BaseSignInMessageSignerWalletAdapter = BaseSignInMessageSignerWalletAdapter;","map":{"version":3,"names":["adapter_js_1","require","errors_js_1","transaction_js_1","BaseSignerWalletAdapter","BaseWalletAdapter","sendTransaction","transaction_1","connection_1","transaction","connection","options","emit","isVersionedTransaction","supportedTransactionVersions","WalletSendTransactionError","has","version","signTransaction","rawTransaction","serialize","sendRawTransaction","error","WalletSignTransactionError","message","signers","sendOptions","__rest","prepareTransaction","length","partialSign","signAllTransactions","transactions","signedTransactions","push","exports","BaseMessageSignerWalletAdapter","BaseSignInMessageSignerWalletAdapter"],"sources":["/home/kokoi/typeracer-app/frontend/node_modules/@solana/wallet-adapter-base/src/signer.ts"],"sourcesContent":["import type { SolanaSignInInput, SolanaSignInOutput } from '@solana/wallet-standard-features';\nimport type { Connection, TransactionSignature } from '@solana/web3.js';\nimport {\n    BaseWalletAdapter,\n    type SendTransactionOptions,\n    type WalletAdapter,\n    type WalletAdapterProps,\n} from './adapter.js';\nimport { WalletSendTransactionError, WalletSignTransactionError } from './errors.js';\nimport { isVersionedTransaction, type TransactionOrVersionedTransaction } from './transaction.js';\n\nexport interface SignerWalletAdapterProps<Name extends string = string> extends WalletAdapterProps<Name> {\n    signTransaction<T extends TransactionOrVersionedTransaction<this['supportedTransactionVersions']>>(\n        transaction: T\n    ): Promise<T>;\n    signAllTransactions<T extends TransactionOrVersionedTransaction<this['supportedTransactionVersions']>>(\n        transactions: T[]\n    ): Promise<T[]>;\n}\n\nexport type SignerWalletAdapter<Name extends string = string> = WalletAdapter<Name> & SignerWalletAdapterProps<Name>;\n\nexport abstract class BaseSignerWalletAdapter<Name extends string = string>\n    extends BaseWalletAdapter<Name>\n    implements SignerWalletAdapter<Name>\n{\n    async sendTransaction(\n        transaction: TransactionOrVersionedTransaction<this['supportedTransactionVersions']>,\n        connection: Connection,\n        options: SendTransactionOptions = {}\n    ): Promise<TransactionSignature> {\n        let emit = true;\n        try {\n            if (isVersionedTransaction(transaction)) {\n                if (!this.supportedTransactionVersions)\n                    throw new WalletSendTransactionError(\n                        `Sending versioned transactions isn't supported by this wallet`\n                    );\n\n                if (!this.supportedTransactionVersions.has(transaction.version))\n                    throw new WalletSendTransactionError(\n                        `Sending transaction version ${transaction.version} isn't supported by this wallet`\n                    );\n\n                try {\n                    transaction = await this.signTransaction(transaction);\n\n                    const rawTransaction = transaction.serialize();\n\n                    return await connection.sendRawTransaction(rawTransaction, options);\n                } catch (error: any) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof WalletSignTransactionError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new WalletSendTransactionError(error?.message, error);\n                }\n            } else {\n                try {\n                    const { signers, ...sendOptions } = options;\n\n                    transaction = await this.prepareTransaction(transaction, connection, sendOptions);\n\n                    signers?.length && transaction.partialSign(...signers);\n\n                    transaction = await this.signTransaction(transaction);\n\n                    const rawTransaction = transaction.serialize();\n\n                    return await connection.sendRawTransaction(rawTransaction, sendOptions);\n                } catch (error: any) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof WalletSignTransactionError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new WalletSendTransactionError(error?.message, error);\n                }\n            }\n        } catch (error: any) {\n            if (emit) {\n                this.emit('error', error);\n            }\n            throw error;\n        }\n    }\n\n    abstract signTransaction<T extends TransactionOrVersionedTransaction<this['supportedTransactionVersions']>>(\n        transaction: T\n    ): Promise<T>;\n\n    async signAllTransactions<T extends TransactionOrVersionedTransaction<this['supportedTransactionVersions']>>(\n        transactions: T[]\n    ): Promise<T[]> {\n        for (const transaction of transactions) {\n            if (isVersionedTransaction(transaction)) {\n                if (!this.supportedTransactionVersions)\n                    throw new WalletSignTransactionError(\n                        `Signing versioned transactions isn't supported by this wallet`\n                    );\n\n                if (!this.supportedTransactionVersions.has(transaction.version))\n                    throw new WalletSignTransactionError(\n                        `Signing transaction version ${transaction.version} isn't supported by this wallet`\n                    );\n            }\n        }\n\n        const signedTransactions: T[] = [];\n        for (const transaction of transactions) {\n            signedTransactions.push(await this.signTransaction(transaction));\n        }\n        return signedTransactions;\n    }\n}\n\nexport interface MessageSignerWalletAdapterProps<Name extends string = string> extends WalletAdapterProps<Name> {\n    signMessage(message: Uint8Array): Promise<Uint8Array>;\n}\n\nexport type MessageSignerWalletAdapter<Name extends string = string> = WalletAdapter<Name> &\n    MessageSignerWalletAdapterProps<Name>;\n\nexport abstract class BaseMessageSignerWalletAdapter<Name extends string = string>\n    extends BaseSignerWalletAdapter<Name>\n    implements MessageSignerWalletAdapter<Name>\n{\n    abstract signMessage(message: Uint8Array): Promise<Uint8Array>;\n}\n\nexport interface SignInMessageSignerWalletAdapterProps<Name extends string = string> extends WalletAdapterProps<Name> {\n    signIn(input?: SolanaSignInInput): Promise<SolanaSignInOutput>;\n}\n\nexport type SignInMessageSignerWalletAdapter<Name extends string = string> = WalletAdapter<Name> &\n    SignInMessageSignerWalletAdapterProps<Name>;\n\nexport abstract class BaseSignInMessageSignerWalletAdapter<Name extends string = string>\n    extends BaseMessageSignerWalletAdapter<Name>\n    implements SignInMessageSignerWalletAdapter<Name>\n{\n    abstract signIn(input?: SolanaSignInInput): Promise<SolanaSignInOutput>;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}