{"ast":null,"code":"import Transport from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/hid-framing\";\nimport { identifyUSBProductId, ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportOpenUserCancelled, DisconnectedDeviceDuringOperation, DisconnectedDevice, TransportError } from \"@ledgerhq/errors\";\nconst ledgerDevices = [{\n  vendorId: ledgerUSBVendorId\n}];\nconst isSupported = () => Promise.resolve(!!(window.navigator && window.navigator.hid));\nconst getHID = () => {\n  // $FlowFixMe\n  const {\n    hid\n  } = navigator;\n  if (!hid) throw new TransportError(\"navigator.hid is not supported\", \"HIDNotSupported\");\n  return hid;\n};\nasync function requestLedgerDevices() {\n  const device = await getHID().requestDevice({\n    filters: ledgerDevices\n  });\n  if (Array.isArray(device)) return device;\n  return [device];\n}\nasync function getLedgerDevices() {\n  const devices = await getHID().getDevices();\n  return devices.filter(d => d.vendorId === ledgerUSBVendorId);\n}\nasync function getFirstLedgerDevice() {\n  const existingDevices = await getLedgerDevices();\n  if (existingDevices.length > 0) return existingDevices[0];\n  const devices = await requestLedgerDevices();\n  return devices[0];\n}\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\nexport default class TransportWebHID extends Transport {\n  device;\n  deviceModel;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n  constructor(device) {\n    super();\n    this.device = device;\n    this.deviceModel = typeof device.productId === \"number\" ? identifyUSBProductId(device.productId) : undefined;\n    device.addEventListener(\"inputreport\", this.onInputReport);\n  }\n  inputs = [];\n  inputCallback;\n  read = () => {\n    if (this.inputs.length) {\n      return Promise.resolve(this.inputs.shift());\n    }\n    return new Promise(success => {\n      this.inputCallback = success;\n    });\n  };\n  onInputReport = e => {\n    const buffer = Buffer.from(e.data.buffer);\n    if (this.inputCallback) {\n      this.inputCallback(buffer);\n      this.inputCallback = null;\n    } else {\n      this.inputs.push(buffer);\n    }\n  };\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = observer => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(device => {\n      if (!device) {\n        observer.error(new TransportOpenUserCancelled(\"Access denied to use Ledger device\"));\n      } else if (!unsubscribed) {\n        const deviceModel = typeof device.productId === \"number\" ? identifyUSBProductId(device.productId) : undefined;\n        observer.next({\n          type: \"add\",\n          descriptor: device,\n          deviceModel\n        });\n        observer.complete();\n      }\n    }, error => {\n      observer.error(new TransportOpenUserCancelled(error.message));\n    });\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return {\n      unsubscribe\n    };\n  };\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const [device] = await requestLedgerDevices();\n    return TransportWebHID.open(device);\n  }\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebHID.open(devices[0]);\n  }\n  /**\n   * Create a Ledger transport with a HIDDevice\n   */\n  static async open(device) {\n    await device.open();\n    const transport = new TransportWebHID(device);\n    const onDisconnect = e => {\n      if (device === e.device) {\n        getHID().removeEventListener(\"disconnect\", onDisconnect);\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n    getHID().addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n  _disconnectEmitted = false;\n  _emitDisconnect = e => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n  /**\n   * Release the transport device\n   */\n  async close() {\n    await this.exchangeBusyPromise;\n    this.device.removeEventListener(\"inputreport\", this.onInputReport);\n    await this.device.close();\n  }\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = async apdu => {\n    const b = await this.exchangeAtomicImpl(async () => {\n      const {\n        channel,\n        packetSize\n      } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n      const framing = hidFraming(channel, packetSize);\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.sendReport(0, blocks[i]);\n      }\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        try {\n          const buffer = await this.read();\n          acc = framing.reduceResponse(acc, buffer);\n        } catch (e) {\n          if (e instanceof TransportError && e.id === \"InvalidChannel\") {\n            // this can happen if the device is connected\n            // on a different channel (like another app)\n            // in this case we just filter out the event\n            continue;\n          }\n          throw e;\n        }\n      }\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch(e => {\n      if (e && e.message && e.message.includes(\"write\")) {\n        this._emitDisconnect(e);\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n      throw e;\n    });\n    return b;\n  };\n  setScrambleKey() {}\n}","map":{"version":3,"names":["Transport","hidFraming","identifyUSBProductId","ledgerUSBVendorId","log","TransportOpenUserCancelled","DisconnectedDeviceDuringOperation","DisconnectedDevice","TransportError","ledgerDevices","vendorId","isSupported","Promise","resolve","window","navigator","hid","getHID","requestLedgerDevices","device","requestDevice","filters","Array","isArray","getLedgerDevices","devices","getDevices","filter","d","getFirstLedgerDevice","existingDevices","length","TransportWebHID","deviceModel","channel","Math","floor","random","packetSize","constructor","productId","undefined","addEventListener","onInputReport","inputs","inputCallback","read","shift","success","e","buffer","Buffer","from","data","push","list","listen","observer","unsubscribed","then","error","next","type","descriptor","complete","message","unsubscribe","request","open","openConnected","transport","onDisconnect","removeEventListener","_emitDisconnect","_disconnectEmitted","emit","close","exchangeBusyPromise","exchange","apdu","b","exchangeAtomicImpl","toString","framing","blocks","makeBlocks","i","sendReport","result","acc","getReducedResult","reduceResponse","id","catch","includes","setScrambleKey"],"sources":["/home/kokoi/typeracer-app/frontend/node_modules/@ledgerhq/hw-transport-webhid/src/TransportWebHID.ts"],"sourcesContent":["import Transport from \"@ledgerhq/hw-transport\";\nimport type { Observer, DescriptorEvent, Subscription } from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/hid-framing\";\nimport { identifyUSBProductId, ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport {\n  TransportOpenUserCancelled,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice,\n  TransportError,\n} from \"@ledgerhq/errors\";\n\nconst ledgerDevices = [\n  {\n    vendorId: ledgerUSBVendorId,\n  },\n];\n\nconst isSupported = () => Promise.resolve(!!(window.navigator && window.navigator.hid));\n\nconst getHID = (): HID => {\n  // $FlowFixMe\n  const { hid } = navigator;\n  if (!hid) throw new TransportError(\"navigator.hid is not supported\", \"HIDNotSupported\");\n  return hid;\n};\n\nasync function requestLedgerDevices(): Promise<HIDDevice[]> {\n  const device = await getHID().requestDevice({\n    filters: ledgerDevices,\n  });\n  if (Array.isArray(device)) return device;\n  return [device];\n}\n\nasync function getLedgerDevices(): Promise<HIDDevice[]> {\n  const devices = await getHID().getDevices();\n  return devices.filter(d => d.vendorId === ledgerUSBVendorId);\n}\n\nasync function getFirstLedgerDevice(): Promise<HIDDevice> {\n  const existingDevices = await getLedgerDevices();\n  if (existingDevices.length > 0) return existingDevices[0];\n  const devices = await requestLedgerDevices();\n  return devices[0];\n}\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\n\nexport default class TransportWebHID extends Transport {\n  device: HIDDevice;\n  deviceModel: DeviceModel | null | undefined;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n\n  constructor(device: HIDDevice) {\n    super();\n    this.device = device;\n    this.deviceModel =\n      typeof device.productId === \"number\" ? identifyUSBProductId(device.productId) : undefined;\n    device.addEventListener(\"inputreport\", this.onInputReport);\n  }\n\n  inputs: Buffer[] = [];\n  inputCallback: ((arg0: Buffer) => void) | null | undefined;\n  read = (): Promise<Buffer> => {\n    if (this.inputs.length) {\n      return Promise.resolve(this.inputs.shift() as unknown as Buffer);\n    }\n\n    return new Promise(success => {\n      this.inputCallback = success;\n    });\n  };\n  onInputReport = (e: HIDInputReportEvent) => {\n    const buffer = Buffer.from(e.data.buffer);\n\n    if (this.inputCallback) {\n      this.inputCallback(buffer);\n      this.inputCallback = null;\n    } else {\n      this.inputs.push(buffer);\n    }\n  };\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (observer: Observer<DescriptorEvent<HIDDevice>>): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      device => {\n        if (!device) {\n          observer.error(new TransportOpenUserCancelled(\"Access denied to use Ledger device\"));\n        } else if (!unsubscribed) {\n          const deviceModel =\n            typeof device.productId === \"number\"\n              ? identifyUSBProductId(device.productId)\n              : undefined;\n          observer.next({\n            type: \"add\",\n            descriptor: device,\n            deviceModel,\n          });\n          observer.complete();\n        }\n      },\n      error => {\n        observer.error(new TransportOpenUserCancelled(error.message));\n      },\n    );\n\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n\n    return {\n      unsubscribe,\n    };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const [device] = await requestLedgerDevices();\n    return TransportWebHID.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebHID.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a HIDDevice\n   */\n  static async open(device: HIDDevice) {\n    await device.open();\n    const transport = new TransportWebHID(device);\n\n    const onDisconnect = e => {\n      if (device === e.device) {\n        getHID().removeEventListener(\"disconnect\", onDisconnect);\n\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n\n    getHID().addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    this.device.removeEventListener(\"inputreport\", this.onInputReport);\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = async (apdu: Buffer): Promise<Buffer> => {\n    const b = await this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n      const framing = hidFraming(channel, packetSize);\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.sendReport(0, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n\n      while (!(result = framing.getReducedResult(acc))) {\n        try {\n          const buffer = await this.read();\n          acc = framing.reduceResponse(acc, buffer);\n        } catch (e) {\n          if (e instanceof TransportError && e.id === \"InvalidChannel\") {\n            // this can happen if the device is connected\n            // on a different channel (like another app)\n            // in this case we just filter out the event\n            continue;\n          }\n\n          throw e;\n        }\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch(e => {\n      if (e && e.message && e.message.includes(\"write\")) {\n        this._emitDisconnect(e);\n\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n\n      throw e;\n    });\n    return b as Buffer;\n  };\n\n  setScrambleKey() {}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}