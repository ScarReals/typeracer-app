{"ast":null,"code":"'use strict';\n\nvar Transform = require('stream').Transform;\nvar inherits = require('inherits');\nfunction HashBase(blockSize) {\n  Transform.call(this);\n  this._block = new Buffer(blockSize);\n  this._blockSize = blockSize;\n  this._blockOffset = 0;\n  this._length = [0, 0, 0, 0];\n  this._finalized = false;\n}\ninherits(HashBase, Transform);\nHashBase.prototype._transform = function (chunk, encoding, callback) {\n  var error = null;\n  try {\n    if (encoding !== 'buffer') chunk = new Buffer(chunk, encoding);\n    this.update(chunk);\n  } catch (err) {\n    error = err;\n  }\n  callback(error);\n};\nHashBase.prototype._flush = function (callback) {\n  var error = null;\n  try {\n    this.push(this._digest());\n  } catch (err) {\n    error = err;\n  }\n  callback(error);\n};\nHashBase.prototype.update = function (data, encoding) {\n  if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer');\n  if (this._finalized) throw new Error('Digest already called');\n  if (!Buffer.isBuffer(data)) data = new Buffer(data, encoding || 'binary');\n\n  // consume data\n  var block = this._block;\n  var offset = 0;\n  while (this._blockOffset + data.length - offset >= this._blockSize) {\n    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++];\n    this._update();\n    this._blockOffset = 0;\n  }\n  while (offset < data.length) block[this._blockOffset++] = data[offset++];\n\n  // update length\n  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {\n    this._length[j] += carry;\n    carry = this._length[j] / 0x0100000000 | 0;\n    if (carry > 0) this._length[j] -= 0x0100000000 * carry;\n  }\n  return this;\n};\nHashBase.prototype._update = function (data) {\n  throw new Error('_update is not implemented');\n};\nHashBase.prototype.digest = function (encoding) {\n  if (this._finalized) throw new Error('Digest already called');\n  this._finalized = true;\n  var digest = this._digest();\n  if (encoding !== undefined) digest = digest.toString(encoding);\n  return digest;\n};\nHashBase.prototype._digest = function () {\n  throw new Error('_digest is not implemented');\n};\nmodule.exports = HashBase;","map":{"version":3,"names":["Transform","require","inherits","HashBase","blockSize","call","_block","Buffer","_blockSize","_blockOffset","_length","_finalized","prototype","_transform","chunk","encoding","callback","error","update","err","_flush","push","_digest","data","isBuffer","TypeError","Error","block","offset","length","i","_update","j","carry","digest","undefined","toString","module","exports"],"sources":["/home/kokoi/typeracer-app/frontend/node_modules/pbkdf2/node_modules/hash-base/index.js"],"sourcesContent":["'use strict'\nvar Transform = require('stream').Transform\nvar inherits = require('inherits')\n\nfunction HashBase (blockSize) {\n  Transform.call(this)\n\n  this._block = new Buffer(blockSize)\n  this._blockSize = blockSize\n  this._blockOffset = 0\n  this._length = [0, 0, 0, 0]\n\n  this._finalized = false\n}\n\ninherits(HashBase, Transform)\n\nHashBase.prototype._transform = function (chunk, encoding, callback) {\n  var error = null\n  try {\n    if (encoding !== 'buffer') chunk = new Buffer(chunk, encoding)\n    this.update(chunk)\n  } catch (err) {\n    error = err\n  }\n\n  callback(error)\n}\n\nHashBase.prototype._flush = function (callback) {\n  var error = null\n  try {\n    this.push(this._digest())\n  } catch (err) {\n    error = err\n  }\n\n  callback(error)\n}\n\nHashBase.prototype.update = function (data, encoding) {\n  if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')\n  if (this._finalized) throw new Error('Digest already called')\n  if (!Buffer.isBuffer(data)) data = new Buffer(data, encoding || 'binary')\n\n  // consume data\n  var block = this._block\n  var offset = 0\n  while (this._blockOffset + data.length - offset >= this._blockSize) {\n    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]\n    this._update()\n    this._blockOffset = 0\n  }\n  while (offset < data.length) block[this._blockOffset++] = data[offset++]\n\n  // update length\n  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {\n    this._length[j] += carry\n    carry = (this._length[j] / 0x0100000000) | 0\n    if (carry > 0) this._length[j] -= 0x0100000000 * carry\n  }\n\n  return this\n}\n\nHashBase.prototype._update = function (data) {\n  throw new Error('_update is not implemented')\n}\n\nHashBase.prototype.digest = function (encoding) {\n  if (this._finalized) throw new Error('Digest already called')\n  this._finalized = true\n\n  var digest = this._digest()\n  if (encoding !== undefined) digest = digest.toString(encoding)\n  return digest\n}\n\nHashBase.prototype._digest = function () {\n  throw new Error('_digest is not implemented')\n}\n\nmodule.exports = HashBase\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}