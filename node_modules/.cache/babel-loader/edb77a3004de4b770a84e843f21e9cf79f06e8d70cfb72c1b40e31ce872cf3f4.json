{"ast":null,"code":"/**\n * Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y².\n * For design rationale of types / exports, see weierstrass module documentation.\n * Untwisted Edwards curves exist, but they aren't used in real-world protocols.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { _validateObject, abool, abytes, aInRange, bytesToHex, bytesToNumberLE, concatBytes, ensureBytes, memoized, numberToBytesLE, randomBytes } from \"../utils.js\";\nimport { _createCurveFields, normalizeZ, pippenger, wNAF } from \"./curve.js\";\nimport { Field } from \"./modular.js\";\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0),\n  _1n = BigInt(1),\n  _2n = BigInt(2),\n  _8n = BigInt(8);\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = {\n  zip215: true\n};\nfunction isEdValidXY(Fp, CURVE, x, y) {\n  const x2 = Fp.sqr(x);\n  const y2 = Fp.sqr(y);\n  const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n  const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n  return Fp.eql(left, right);\n}\nexport function edwards(CURVE, curveOpts = {}) {\n  const {\n    Fp,\n    Fn\n  } = _createCurveFields('edwards', CURVE, curveOpts);\n  const {\n    h: cofactor,\n    n: CURVE_ORDER\n  } = CURVE;\n  _validateObject(curveOpts, {}, {\n    uvRatio: 'function'\n  });\n  // Important:\n  // There are some places where Fp.BYTES is used instead of nByteLength.\n  // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n  // TODO: test and find curves which behave otherwise.\n  const MASK = _2n << BigInt(Fn.BYTES * 8) - _1n;\n  const modP = n => Fp.create(n); // Function overrides\n  // sqrt(u/v)\n  const uvRatio = curveOpts.uvRatio || ((u, v) => {\n    try {\n      return {\n        isValid: true,\n        value: Fp.sqrt(Fp.div(u, v))\n      };\n    } catch (e) {\n      return {\n        isValid: false,\n        value: _0n\n      };\n    }\n  });\n  // Validate whether the passed curve params are valid.\n  // equation ax² + y² = 1 + dx²y² should work for generator point.\n  if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy)) throw new Error('bad curve params: generator point');\n  /**\n   * Asserts coordinate is valid: 0 <= n < MASK.\n   * Coordinates >= Fp.ORDER are allowed for zip215.\n   */\n  function acoord(title, n, banZero = false) {\n    const min = banZero ? _1n : _0n;\n    aInRange('coordinate ' + title, n, min, MASK);\n    return n;\n  }\n  function aextpoint(other) {\n    if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');\n  }\n  // Converts Extended point to default (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  const toAffineMemo = memoized((p, iz) => {\n    const {\n      ex: x,\n      ey: y,\n      ez: z\n    } = p;\n    const is0 = p.is0();\n    if (iz == null) iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily\n    const ax = modP(x * iz);\n    const ay = modP(y * iz);\n    const zz = modP(z * iz);\n    if (is0) return {\n      x: _0n,\n      y: _1n\n    };\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return {\n      x: ax,\n      y: ay\n    };\n  });\n  const assertValidMemo = memoized(p => {\n    const {\n      a,\n      d\n    } = CURVE;\n    if (p.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n    // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n    // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n    const {\n      ex: X,\n      ey: Y,\n      ez: Z,\n      et: T\n    } = p;\n    const X2 = modP(X * X); // X²\n    const Y2 = modP(Y * Y); // Y²\n    const Z2 = modP(Z * Z); // Z²\n    const Z4 = modP(Z2 * Z2); // Z⁴\n    const aX2 = modP(X2 * a); // aX²\n    const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n    const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n    if (left !== right) throw new Error('bad point: equation left != right (1)');\n    // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n    const XY = modP(X * Y);\n    const ZT = modP(Z * T);\n    if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    return true;\n  });\n  // Extended Point works in extended coordinates: (X, Y, Z, T) ∋ (x=X/Z, y=Y/Z, T=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point {\n    constructor(ex, ey, ez, et) {\n      this.ex = acoord('x', ex);\n      this.ey = acoord('y', ey);\n      this.ez = acoord('z', ez, true);\n      this.et = acoord('t', et);\n      Object.freeze(this);\n    }\n    get x() {\n      return this.toAffine().x;\n    }\n    get y() {\n      return this.toAffine().y;\n    }\n    static fromAffine(p) {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const {\n        x,\n        y\n      } = p || {};\n      acoord('x', x);\n      acoord('y', y);\n      return new Point(x, y, _1n, modP(x * y));\n    }\n    static normalizeZ(points) {\n      return normalizeZ(Point, 'ez', points);\n    }\n    // Multiscalar Multiplication\n    static msm(points, scalars) {\n      return pippenger(Point, Fn, points, scalars);\n    }\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize) {\n      this.precompute(windowSize);\n    }\n    precompute(windowSize = 8, isLazy = true) {\n      wnaf.setWindowSize(this, windowSize);\n      if (!isLazy) this.multiply(_2n); // random number\n      return this;\n    }\n    // Not required for fromHex(), which always creates valid points.\n    // Could be useful for fromAffine().\n    assertValidity() {\n      assertValidMemo(this);\n    }\n    // Compare one point to another.\n    equals(other) {\n      aextpoint(other);\n      const {\n        ex: X1,\n        ey: Y1,\n        ez: Z1\n      } = this;\n      const {\n        ex: X2,\n        ey: Y2,\n        ez: Z2\n      } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    is0() {\n      return this.equals(Point.ZERO);\n    }\n    negate() {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n    }\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double() {\n      const {\n        a\n      } = CURVE;\n      const {\n        ex: X1,\n        ey: Y1,\n        ez: Z1\n      } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other) {\n      aextpoint(other);\n      const {\n        a,\n        d\n      } = CURVE;\n      const {\n        ex: X1,\n        ey: Y1,\n        ez: Z1,\n        et: T1\n      } = this;\n      const {\n        ex: X2,\n        ey: Y2,\n        ez: Z2,\n        et: T2\n      } = other;\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n    subtract(other) {\n      return this.add(other.negate());\n    }\n    // Constant-time multiplication.\n    multiply(scalar) {\n      const n = scalar;\n      aInRange('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L\n      const {\n        p,\n        f\n      } = wnaf.wNAFCached(this, n, Point.normalizeZ);\n      return Point.normalizeZ([p, f])[0];\n    }\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n    multiplyUnsafe(scalar, acc = Point.ZERO) {\n      const n = scalar;\n      aInRange('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L\n      if (n === _0n) return Point.ZERO;\n      if (this.is0() || n === _1n) return this;\n      return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);\n    }\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder() {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree() {\n      return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();\n    }\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(invertedZ) {\n      return toAffineMemo(this, invertedZ);\n    }\n    clearCofactor() {\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n    static fromBytes(bytes, zip215 = false) {\n      abytes(bytes);\n      return this.fromHex(bytes, zip215);\n    }\n    // Converts hash string or Uint8Array to Point.\n    // Uses algo from RFC8032 5.1.3.\n    static fromHex(hex, zip215 = false) {\n      const {\n        d,\n        a\n      } = CURVE;\n      const len = Fp.BYTES;\n      hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n      abool('zip215', zip215);\n      const normed = hex.slice(); // copy again, we'll manipulate it\n      const lastByte = hex[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = bytesToNumberLE(normed);\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // RFC8032 prohibits >= p, but ZIP215 doesn't\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      const max = zip215 ? MASK : Fp.ORDER;\n      aInRange('pointHex.y', y, _0n, max);\n      // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n      // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y² - 1\n      const v = modP(d * y2 - a); // v = d y² + 1.\n      let {\n        isValid,\n        value: x\n      } = uvRatio(u, v); // √(u/v)\n      if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('Point.fromHex: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({\n        x,\n        y\n      });\n    }\n    static fromPrivateScalar(scalar) {\n      return Point.BASE.multiply(scalar);\n    }\n    toBytes() {\n      const {\n        x,\n        y\n      } = this.toAffine();\n      const bytes = numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n      return bytes; // and use the last byte to encode sign of x\n    }\n    /** @deprecated use `toBytes` */\n    toRawBytes() {\n      return this.toBytes();\n    }\n    toHex() {\n      return bytesToHex(this.toBytes());\n    }\n    toString() {\n      return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n    }\n  }\n  // base / generator point\n  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n  // zero / infinity / identity point\n  Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n  // fields\n  Point.Fp = Fp;\n  Point.Fn = Fn;\n  const wnaf = wNAF(Point, Fn.BYTES * 8); // Fn.BITS?\n  return Point;\n}\n/**\n * Initializes EdDSA signatures over given Edwards curve.\n */\nexport function eddsa(Point, eddsaOpts) {\n  _validateObject(eddsaOpts, {\n    hash: 'function'\n  }, {\n    adjustScalarBytes: 'function',\n    randomBytes: 'function',\n    domain: 'function',\n    prehash: 'function',\n    mapToCurve: 'function'\n  });\n  const {\n    prehash,\n    hash: cHash\n  } = eddsaOpts;\n  const {\n    BASE: G,\n    Fp,\n    Fn\n  } = Point;\n  const CURVE_ORDER = Fn.ORDER;\n  const randomBytes_ = eddsaOpts.randomBytes || randomBytes;\n  const adjustScalarBytes = eddsaOpts.adjustScalarBytes || (bytes => bytes); // NOOP\n  const domain = eddsaOpts.domain || ((data, ctx, phflag) => {\n    abool('phflag', phflag);\n    if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n    return data;\n  }); // NOOP\n  function modN(a) {\n    return Fn.create(a);\n  }\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash) {\n    // Not using Fn.fromBytes: hash can be 2*Fn.BYTES\n    return modN(bytesToNumberLE(hash));\n  }\n  // Get the hashed private scalar per RFC8032 5.1.5\n  function getPrivateScalar(key) {\n    const len = Fp.BYTES;\n    key = ensureBytes('private key', key, len);\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    return {\n      head,\n      prefix,\n      scalar\n    };\n  }\n  // Convenience method that creates public key from scalar. RFC8032 5.1.5\n  function getExtendedPublicKey(key) {\n    const {\n      head,\n      prefix,\n      scalar\n    } = getPrivateScalar(key);\n    const point = G.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toBytes();\n    return {\n      head,\n      prefix,\n      scalar,\n      point,\n      pointBytes\n    };\n  }\n  // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n  function getPublicKey(privKey) {\n    return getExtendedPublicKey(privKey).pointBytes;\n  }\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {\n    const msg = concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n  }\n  /** Signs message with privateKey. RFC8032 5.1.6 */\n  function sign(msg, privKey, options = {}) {\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const {\n      prefix,\n      scalar,\n      pointBytes\n    } = getExtendedPublicKey(privKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = G.multiply(r).toBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = modN(r + k * scalar); // S = (r + k * s) mod L\n    aInRange('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l\n    const L = Fp.BYTES;\n    const res = concatBytes(R, numberToBytesLE(s, L));\n    return ensureBytes('result', res, L * 2); // 64-byte signature\n  }\n  const verifyOpts = VERIFY_DEFAULT;\n  /**\n   * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n   * An extended group equation is checked.\n   */\n  function verify(sig, msg, publicKey, options = verifyOpts) {\n    const {\n      context,\n      zip215\n    } = options;\n    const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n    sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n    msg = ensureBytes('message', msg);\n    publicKey = ensureBytes('publicKey', publicKey, len);\n    if (zip215 !== undefined) abool('zip215', zip215);\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n    const s = bytesToNumberLE(sig.slice(len, 2 * len));\n    let A, R, SB;\n    try {\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      A = Point.fromHex(publicKey, zip215);\n      R = Point.fromHex(sig.slice(0, len), zip215);\n      SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false;\n    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // Extended group equation\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().is0();\n  }\n  G.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n  const utils = {\n    getExtendedPublicKey,\n    /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */\n    randomPrivateKey: () => randomBytes_(Fp.BYTES),\n    /**\n     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n     * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n     * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n     * @param windowSize 2, 4, 8, 16\n     */\n    precompute(windowSize = 8, point = Point.BASE) {\n      return point.precompute(windowSize, false);\n    }\n  };\n  return {\n    getPublicKey,\n    sign,\n    verify,\n    utils,\n    Point\n  };\n}\nfunction _eddsa_legacy_opts_to_new(c) {\n  const CURVE = {\n    a: c.a,\n    d: c.d,\n    p: c.Fp.ORDER,\n    n: c.n,\n    h: c.h,\n    Gx: c.Gx,\n    Gy: c.Gy\n  };\n  const Fp = c.Fp;\n  const Fn = Field(CURVE.n, c.nBitLength, true);\n  const curveOpts = {\n    Fp,\n    Fn,\n    uvRatio: c.uvRatio\n  };\n  const eddsaOpts = {\n    hash: c.hash,\n    randomBytes: c.randomBytes,\n    adjustScalarBytes: c.adjustScalarBytes,\n    domain: c.domain,\n    prehash: c.prehash,\n    mapToCurve: c.mapToCurve\n  };\n  return {\n    CURVE,\n    curveOpts,\n    eddsaOpts\n  };\n}\nfunction _eddsa_new_output_to_legacy(c, eddsa) {\n  const legacy = Object.assign({}, eddsa, {\n    ExtendedPoint: eddsa.Point,\n    CURVE: c\n  });\n  return legacy;\n}\n// TODO: remove. Use eddsa\nexport function twistedEdwards(c) {\n  const {\n    CURVE,\n    curveOpts,\n    eddsaOpts\n  } = _eddsa_legacy_opts_to_new(c);\n  const Point = edwards(CURVE, curveOpts);\n  const EDDSA = eddsa(Point, eddsaOpts);\n  return _eddsa_new_output_to_legacy(c, EDDSA);\n}","map":{"version":3,"names":["_validateObject","abool","abytes","aInRange","bytesToHex","bytesToNumberLE","concatBytes","ensureBytes","memoized","numberToBytesLE","randomBytes","_createCurveFields","normalizeZ","pippenger","wNAF","Field","_0n","BigInt","_1n","_2n","_8n","VERIFY_DEFAULT","zip215","isEdValidXY","Fp","CURVE","x","y","x2","sqr","y2","left","add","mul","a","right","ONE","d","eql","edwards","curveOpts","Fn","h","cofactor","n","CURVE_ORDER","uvRatio","MASK","BYTES","modP","create","u","v","isValid","value","sqrt","div","e","Gx","Gy","Error","acoord","title","banZero","min","aextpoint","other","Point","toAffineMemo","p","iz","ex","ey","ez","z","is0","inv","ax","ay","zz","assertValidMemo","X","Y","Z","et","T","X2","Y2","Z2","Z4","aX2","XY","ZT","constructor","Object","freeze","toAffine","fromAffine","points","msm","scalars","_setWindowSize","windowSize","precompute","isLazy","wnaf","setWindowSize","multiply","assertValidity","equals","X1","Y1","Z1","X1Z2","X2Z1","Y1Z2","Y2Z1","ZERO","negate","double","A","B","C","D","x1y1","E","G","F","H","X3","Y3","T3","Z3","T1","T2","subtract","scalar","f","wNAFCached","multiplyUnsafe","acc","wNAFCachedUnsafe","isSmallOrder","isTorsionFree","invertedZ","clearCofactor","fromBytes","bytes","fromHex","hex","len","normed","slice","lastByte","max","ORDER","isXOdd","isLastByteOdd","fromPrivateScalar","BASE","toBytes","length","toRawBytes","toHex","toString","eddsa","eddsaOpts","hash","adjustScalarBytes","domain","prehash","mapToCurve","cHash","randomBytes_","data","ctx","phflag","modN","modN_LE","getPrivateScalar","key","hashed","head","prefix","getExtendedPublicKey","point","pointBytes","getPublicKey","privKey","hashDomainToScalar","context","Uint8Array","of","msgs","msg","sign","options","r","R","k","s","L","res","verifyOpts","verify","sig","publicKey","undefined","SB","error","RkA","utils","randomPrivateKey","_eddsa_legacy_opts_to_new","c","nBitLength","_eddsa_new_output_to_legacy","legacy","assign","ExtendedPoint","twistedEdwards","EDDSA"],"sources":["/home/kokoi/sol-wager-app/frontend/node_modules/@noble/curves/src/abstract/edwards.ts"],"sourcesContent":["/**\n * Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y².\n * For design rationale of types / exports, see weierstrass module documentation.\n * Untwisted Edwards curves exist, but they aren't used in real-world protocols.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  _validateObject,\n  abool,\n  abytes,\n  aInRange,\n  bytesToHex,\n  bytesToNumberLE,\n  concatBytes,\n  ensureBytes,\n  memoized,\n  numberToBytesLE,\n  randomBytes,\n  type FHash,\n  type Hex,\n} from '../utils.ts';\nimport {\n  _createCurveFields,\n  normalizeZ,\n  pippenger,\n  wNAF,\n  type AffinePoint,\n  type BasicCurve,\n  type Group,\n  type GroupConstructor,\n} from './curve.ts';\nimport { Field, type IField, type NLength } from './modular.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n\nexport type UVRatio = (u: bigint, v: bigint) => { isValid: boolean; value: bigint };\n\n/** Edwards curves must declare params a & d. */\nexport type CurveType = BasicCurve<bigint> & {\n  a: bigint; // curve param a\n  d: bigint; // curve param d\n  hash: FHash; // Hashing\n  randomBytes?: (bytesLength?: number) => Uint8Array; // CSPRNG\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array; // clears bits to get valid field elemtn\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array; // Used for hashing\n  uvRatio?: UVRatio; // Ratio √(u/v)\n  prehash?: FHash; // RFC 8032 pre-hashing of messages to sign() / verify()\n  mapToCurve?: (scalar: bigint[]) => AffinePoint<bigint>; // for hash-to-curve standard\n};\n\nexport type CurveTypeWithLength = Readonly<CurveType & Partial<NLength>>;\n\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\n\n/** Instance of Extended Point with coordinates in X, Y, Z, T. */\nexport interface ExtPointType extends Group<ExtPointType> {\n  readonly ex: bigint;\n  readonly ey: bigint;\n  readonly ez: bigint;\n  readonly et: bigint;\n  get x(): bigint;\n  get y(): bigint;\n  assertValidity(): void;\n  multiply(scalar: bigint): ExtPointType;\n  multiplyUnsafe(scalar: bigint): ExtPointType;\n  is0(): boolean;\n  isSmallOrder(): boolean;\n  isTorsionFree(): boolean;\n  clearCofactor(): ExtPointType;\n  toAffine(iz?: bigint): AffinePoint<bigint>;\n  toBytes(): Uint8Array;\n  /** @deprecated use `toBytes` */\n  toRawBytes(): Uint8Array;\n  toHex(): string;\n  precompute(windowSize?: number, isLazy?: boolean): ExtPointType;\n  /** @deprecated use `p.precompute(windowSize)` */\n  _setWindowSize(windowSize: number): void;\n}\n/** Static methods of Extended Point with coordinates in X, Y, Z, T. */\nexport interface ExtPointConstructor extends GroupConstructor<ExtPointType> {\n  new (x: bigint, y: bigint, z: bigint, t: bigint): ExtPointType;\n  Fp: IField<bigint>;\n  Fn: IField<bigint>;\n  fromAffine(p: AffinePoint<bigint>): ExtPointType;\n  fromBytes(bytes: Uint8Array, zip215?: boolean): ExtPointType;\n  fromHex(hex: Hex, zip215?: boolean): ExtPointType;\n  msm(points: ExtPointType[], scalars: bigint[]): ExtPointType;\n}\n\n/**\n * Twisted Edwards curve options.\n *\n * * a: formula param\n * * d: formula param\n * * p: prime characteristic (order) of finite field, in which arithmetics is done\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * h: cofactor. h*n is group order; n is subgroup order\n * * Gx: x coordinate of generator point a.k.a. base point\n * * Gy: y coordinate of generator point\n */\nexport type EdwardsOpts = Readonly<{\n  a: bigint;\n  d: bigint;\n  p: bigint;\n  n: bigint;\n  h: bigint;\n  Gx: bigint;\n  Gy: bigint;\n}>;\n\n/**\n * Extra curve options for Twisted Edwards.\n *\n * * Fp: redefined Field over curve.p\n * * Fn: redefined Field over curve.n\n * * uvRatio: helper function for decompression, calculating √(u/v)\n */\nexport type EdwardsExtraOpts = Partial<{\n  Fp: IField<bigint>;\n  Fn: IField<bigint>;\n  uvRatio: (u: bigint, v: bigint) => { isValid: boolean; value: bigint };\n}>;\n\n/**\n * EdDSA (Edwards Digital Signature algorithm) options.\n *\n * * hash: hash function used to hash private keys and messages\n * * adjustScalarBytes: clears bits to get valid field element\n * * domain: Used for hashing\n * * mapToCurve: for hash-to-curve standard\n * * prehash: RFC 8032 pre-hashing of messages to sign() / verify()\n * * randomBytes: function generating random bytes, used for randomPrivateKey\n */\nexport type EdDSAOpts = {\n  hash: FHash;\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array;\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array;\n  mapToCurve?: (scalar: bigint[]) => AffinePoint<bigint>;\n  prehash?: FHash;\n  randomBytes?: (bytesLength?: number) => Uint8Array;\n};\n\n/**\n * EdDSA (Edwards Digital Signature algorithm) interface.\n *\n * Allows to create and verify signatures, create public and private keys.\n */\nexport interface EdDSA {\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  sign: (message: Hex, privateKey: Hex, options?: { context?: Hex }) => Uint8Array;\n  verify: (\n    sig: Hex,\n    message: Hex,\n    publicKey: Hex,\n    options?: { context?: Hex; zip215: boolean }\n  ) => boolean;\n  Point: ExtPointConstructor;\n  utils: {\n    randomPrivateKey: () => Uint8Array;\n    getExtendedPublicKey: (key: Hex) => {\n      head: Uint8Array;\n      prefix: Uint8Array;\n      scalar: bigint;\n      point: ExtPointType;\n      pointBytes: Uint8Array;\n    };\n    /** @deprecated use `point.precompute()` */\n    precompute: (windowSize?: number, point?: ExtPointType) => ExtPointType;\n  };\n}\n\n// Legacy params. TODO: remove\nexport type CurveFn = {\n  CURVE: CurveType;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  sign: (message: Hex, privateKey: Hex, options?: { context?: Hex }) => Uint8Array;\n  verify: (\n    sig: Hex,\n    message: Hex,\n    publicKey: Hex,\n    options?: { context?: Hex; zip215: boolean }\n  ) => boolean;\n  Point: ExtPointConstructor;\n  /** @deprecated use `Point` */\n  ExtendedPoint: ExtPointConstructor;\n  utils: {\n    randomPrivateKey: () => Uint8Array;\n    getExtendedPublicKey: (key: Hex) => {\n      head: Uint8Array;\n      prefix: Uint8Array;\n      scalar: bigint;\n      point: ExtPointType;\n      pointBytes: Uint8Array;\n    };\n    precompute: (windowSize?: number, point?: ExtPointType) => ExtPointType;\n  };\n};\n\nfunction isEdValidXY(Fp: IField<bigint>, CURVE: EdwardsOpts, x: bigint, y: bigint): boolean {\n  const x2 = Fp.sqr(x);\n  const y2 = Fp.sqr(y);\n  const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n  const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n  return Fp.eql(left, right);\n}\n\nexport function edwards(CURVE: EdwardsOpts, curveOpts: EdwardsExtraOpts = {}): ExtPointConstructor {\n  const { Fp, Fn } = _createCurveFields('edwards', CURVE, curveOpts);\n  const { h: cofactor, n: CURVE_ORDER } = CURVE;\n  _validateObject(curveOpts, {}, { uvRatio: 'function' });\n\n  // Important:\n  // There are some places where Fp.BYTES is used instead of nByteLength.\n  // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n  // TODO: test and find curves which behave otherwise.\n  const MASK = _2n << (BigInt(Fn.BYTES * 8) - _1n);\n  const modP = (n: bigint) => Fp.create(n); // Function overrides\n\n  // sqrt(u/v)\n  const uvRatio =\n    curveOpts.uvRatio ||\n    ((u: bigint, v: bigint) => {\n      try {\n        return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };\n      } catch (e) {\n        return { isValid: false, value: _0n };\n      }\n    });\n\n  // Validate whether the passed curve params are valid.\n  // equation ax² + y² = 1 + dx²y² should work for generator point.\n  if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))\n    throw new Error('bad curve params: generator point');\n\n  /**\n   * Asserts coordinate is valid: 0 <= n < MASK.\n   * Coordinates >= Fp.ORDER are allowed for zip215.\n   */\n  function acoord(title: string, n: bigint, banZero = false) {\n    const min = banZero ? _1n : _0n;\n    aInRange('coordinate ' + title, n, min, MASK);\n    return n;\n  }\n\n  function aextpoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');\n  }\n  // Converts Extended point to default (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  const toAffineMemo = memoized((p: Point, iz?: bigint): AffinePoint<bigint> => {\n    const { ex: x, ey: y, ez: z } = p;\n    const is0 = p.is0();\n    if (iz == null) iz = is0 ? _8n : (Fp.inv(z) as bigint); // 8 was chosen arbitrarily\n    const ax = modP(x * iz);\n    const ay = modP(y * iz);\n    const zz = modP(z * iz);\n    if (is0) return { x: _0n, y: _1n };\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return { x: ax, y: ay };\n  });\n  const assertValidMemo = memoized((p: Point) => {\n    const { a, d } = CURVE;\n    if (p.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n    // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n    // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n    const { ex: X, ey: Y, ez: Z, et: T } = p;\n    const X2 = modP(X * X); // X²\n    const Y2 = modP(Y * Y); // Y²\n    const Z2 = modP(Z * Z); // Z²\n    const Z4 = modP(Z2 * Z2); // Z⁴\n    const aX2 = modP(X2 * a); // aX²\n    const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n    const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n    if (left !== right) throw new Error('bad point: equation left != right (1)');\n    // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n    const XY = modP(X * Y);\n    const ZT = modP(Z * T);\n    if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    return true;\n  });\n\n  // Extended Point works in extended coordinates: (X, Y, Z, T) ∋ (x=X/Z, y=Y/Z, T=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point implements ExtPointType {\n    // base / generator point\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    // zero / infinity / identity point\n    static readonly ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    // fields\n    static readonly Fp = Fp;\n    static readonly Fn = Fn;\n\n    readonly ex: bigint;\n    readonly ey: bigint;\n    readonly ez: bigint;\n    readonly et: bigint;\n\n    constructor(ex: bigint, ey: bigint, ez: bigint, et: bigint) {\n      this.ex = acoord('x', ex);\n      this.ey = acoord('y', ey);\n      this.ez = acoord('z', ez, true);\n      this.et = acoord('t', et);\n      Object.freeze(this);\n    }\n\n    get x(): bigint {\n      return this.toAffine().x;\n    }\n    get y(): bigint {\n      return this.toAffine().y;\n    }\n\n    static fromAffine(p: AffinePoint<bigint>): Point {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const { x, y } = p || {};\n      acoord('x', x);\n      acoord('y', y);\n      return new Point(x, y, _1n, modP(x * y));\n    }\n    static normalizeZ(points: Point[]): Point[] {\n      return normalizeZ(Point, 'ez', points);\n    }\n    // Multiscalar Multiplication\n    static msm(points: Point[], scalars: bigint[]): Point {\n      return pippenger(Point, Fn, points, scalars);\n    }\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      this.precompute(windowSize);\n    }\n    precompute(windowSize: number = 8, isLazy = true) {\n      wnaf.setWindowSize(this, windowSize);\n      if (!isLazy) this.multiply(_2n); // random number\n      return this;\n    }\n    // Not required for fromHex(), which always creates valid points.\n    // Could be useful for fromAffine().\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    // Compare one point to another.\n    equals(other: Point): boolean {\n      aextpoint(other);\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2 } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n\n    is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    negate(): Point {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n    }\n\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double(): Point {\n      const { a } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other: Point) {\n      aextpoint(other);\n      const { a, d } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    subtract(other: Point): Point {\n      return this.add(other.negate());\n    }\n\n    // Constant-time multiplication.\n    multiply(scalar: bigint): Point {\n      const n = scalar;\n      aInRange('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L\n      const { p, f } = wnaf.wNAFCached(this, n, Point.normalizeZ);\n      return Point.normalizeZ([p, f])[0];\n    }\n\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n    multiplyUnsafe(scalar: bigint, acc = Point.ZERO): Point {\n      const n = scalar;\n      aInRange('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L\n      if (n === _0n) return Point.ZERO;\n      if (this.is0() || n === _1n) return this;\n      return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);\n    }\n\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder(): boolean {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree(): boolean {\n      return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();\n    }\n\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(invertedZ?: bigint): AffinePoint<bigint> {\n      return toAffineMemo(this, invertedZ);\n    }\n\n    clearCofactor(): Point {\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    static fromBytes(bytes: Uint8Array, zip215 = false): Point {\n      abytes(bytes);\n      return this.fromHex(bytes, zip215);\n    }\n\n    // Converts hash string or Uint8Array to Point.\n    // Uses algo from RFC8032 5.1.3.\n    static fromHex(hex: Hex, zip215 = false): Point {\n      const { d, a } = CURVE;\n      const len = Fp.BYTES;\n      hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n      abool('zip215', zip215);\n      const normed = hex.slice(); // copy again, we'll manipulate it\n      const lastByte = hex[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = bytesToNumberLE(normed);\n\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // RFC8032 prohibits >= p, but ZIP215 doesn't\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      const max = zip215 ? MASK : Fp.ORDER;\n      aInRange('pointHex.y', y, _0n, max);\n\n      // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n      // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y² - 1\n      const v = modP(d * y2 - a); // v = d y² + 1.\n      let { isValid, value: x } = uvRatio(u, v); // √(u/v)\n      if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('Point.fromHex: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({ x, y });\n    }\n    static fromPrivateScalar(scalar: bigint): Point {\n      return Point.BASE.multiply(scalar);\n    }\n    toBytes(): Uint8Array {\n      const { x, y } = this.toAffine();\n      const bytes = numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n      return bytes; // and use the last byte to encode sign of x\n    }\n    /** @deprecated use `toBytes` */\n    toRawBytes(): Uint8Array {\n      return this.toBytes();\n    }\n    toHex(): string {\n      return bytesToHex(this.toBytes());\n    }\n\n    toString() {\n      return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n    }\n  }\n  const wnaf = wNAF(Point, Fn.BYTES * 8); // Fn.BITS?\n  return Point;\n}\n\n/**\n * Initializes EdDSA signatures over given Edwards curve.\n */\nexport function eddsa(Point: ExtPointConstructor, eddsaOpts: EdDSAOpts): EdDSA {\n  _validateObject(\n    eddsaOpts,\n    {\n      hash: 'function',\n    },\n    {\n      adjustScalarBytes: 'function',\n      randomBytes: 'function',\n      domain: 'function',\n      prehash: 'function',\n      mapToCurve: 'function',\n    }\n  );\n\n  const { prehash, hash: cHash } = eddsaOpts;\n  const { BASE: G, Fp, Fn } = Point;\n  const CURVE_ORDER = Fn.ORDER;\n\n  const randomBytes_ = eddsaOpts.randomBytes || randomBytes;\n  const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes: Uint8Array) => bytes); // NOOP\n  const domain =\n    eddsaOpts.domain ||\n    ((data: Uint8Array, ctx: Uint8Array, phflag: boolean) => {\n      abool('phflag', phflag);\n      if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n      return data;\n    }); // NOOP\n\n  function modN(a: bigint) {\n    return Fn.create(a);\n  }\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash: Uint8Array): bigint {\n    // Not using Fn.fromBytes: hash can be 2*Fn.BYTES\n    return modN(bytesToNumberLE(hash));\n  }\n\n  // Get the hashed private scalar per RFC8032 5.1.5\n  function getPrivateScalar(key: Hex) {\n    const len = Fp.BYTES;\n    key = ensureBytes('private key', key, len);\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    return { head, prefix, scalar };\n  }\n\n  // Convenience method that creates public key from scalar. RFC8032 5.1.5\n  function getExtendedPublicKey(key: Hex) {\n    const { head, prefix, scalar } = getPrivateScalar(key);\n    const point = G.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toBytes();\n    return { head, prefix, scalar, point, pointBytes };\n  }\n\n  // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n  function getPublicKey(privKey: Hex): Uint8Array {\n    return getExtendedPublicKey(privKey).pointBytes;\n  }\n\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar(context: Hex = Uint8Array.of(), ...msgs: Uint8Array[]) {\n    const msg = concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n  }\n\n  /** Signs message with privateKey. RFC8032 5.1.6 */\n  function sign(msg: Hex, privKey: Hex, options: { context?: Hex } = {}): Uint8Array {\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = G.multiply(r).toBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = modN(r + k * scalar); // S = (r + k * s) mod L\n    aInRange('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l\n    const L = Fp.BYTES;\n    const res = concatBytes(R, numberToBytesLE(s, L));\n    return ensureBytes('result', res, L * 2); // 64-byte signature\n  }\n\n  const verifyOpts: { context?: Hex; zip215?: boolean } = VERIFY_DEFAULT;\n\n  /**\n   * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n   * An extended group equation is checked.\n   */\n  function verify(sig: Hex, msg: Hex, publicKey: Hex, options = verifyOpts): boolean {\n    const { context, zip215 } = options;\n    const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n    sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n    msg = ensureBytes('message', msg);\n    publicKey = ensureBytes('publicKey', publicKey, len);\n    if (zip215 !== undefined) abool('zip215', zip215);\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n\n    const s = bytesToNumberLE(sig.slice(len, 2 * len));\n    let A, R, SB;\n    try {\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      A = Point.fromHex(publicKey, zip215);\n      R = Point.fromHex(sig.slice(0, len), zip215);\n      SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false;\n\n    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // Extended group equation\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().is0();\n  }\n\n  G.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n\n  const utils = {\n    getExtendedPublicKey,\n    /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */\n    randomPrivateKey: (): Uint8Array => randomBytes_!(Fp.BYTES),\n\n    /**\n     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n     * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n     * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n     * @param windowSize 2, 4, 8, 16\n     */\n    precompute(windowSize = 8, point: ExtPointType = Point.BASE): ExtPointType {\n      return point.precompute(windowSize, false);\n    },\n  };\n\n  return { getPublicKey, sign, verify, utils, Point };\n}\n\nexport type EdComposed = {\n  CURVE: EdwardsOpts;\n  curveOpts: EdwardsExtraOpts;\n  eddsaOpts: EdDSAOpts;\n};\nfunction _eddsa_legacy_opts_to_new(c: CurveTypeWithLength): EdComposed {\n  const CURVE: EdwardsOpts = {\n    a: c.a,\n    d: c.d,\n    p: c.Fp.ORDER,\n    n: c.n,\n    h: c.h,\n    Gx: c.Gx,\n    Gy: c.Gy,\n  };\n  const Fp = c.Fp;\n  const Fn = Field(CURVE.n, c.nBitLength, true);\n  const curveOpts: EdwardsExtraOpts = { Fp, Fn, uvRatio: c.uvRatio };\n  const eddsaOpts: EdDSAOpts = {\n    hash: c.hash,\n    randomBytes: c.randomBytes,\n    adjustScalarBytes: c.adjustScalarBytes,\n    domain: c.domain,\n    prehash: c.prehash,\n    mapToCurve: c.mapToCurve,\n  };\n  return { CURVE, curveOpts, eddsaOpts };\n}\nfunction _eddsa_new_output_to_legacy(c: CurveTypeWithLength, eddsa: EdDSA): CurveFn {\n  const legacy = Object.assign({}, eddsa, { ExtendedPoint: eddsa.Point, CURVE: c });\n  return legacy;\n}\n// TODO: remove. Use eddsa\nexport function twistedEdwards(c: CurveTypeWithLength): CurveFn {\n  const { CURVE, curveOpts, eddsaOpts } = _eddsa_legacy_opts_to_new(c);\n  const Point = edwards(CURVE, curveOpts);\n  const EDDSA = eddsa(Point, eddsaOpts);\n  return _eddsa_new_output_to_legacy(c, EDDSA);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}