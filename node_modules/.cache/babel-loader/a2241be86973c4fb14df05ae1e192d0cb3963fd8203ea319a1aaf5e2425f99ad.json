{"ast":null,"code":"var _jsxFileName = \"/home/kokoi/sol-wager-app/frontend/src/App.jsx\",\n  _s = $RefreshSig$();\n// src/App.jsx\n\nimport React, { useState, useEffect, useRef } from \"react\";\nimport \"./App.css\";\nimport sentences from \"./sentences\";\nimport { useConnection, useWallet } from \"@solana/wallet-adapter-react\";\nimport { WalletMultiButton } from \"@solana/wallet-adapter-react-ui\";\nimport { LAMPORTS_PER_SOL, PublicKey, SystemProgram, Transaction } from \"@solana/web3.js\";\nimport socket from \"./socket\";\nimport * as anchor from \"@coral-xyz/anchor\";\nimport { initializeEscrow, joinAndDeposit, depositToEscrow, cancelEscrow, resolveEscrow } from \"./escrow\";\nimport idl from \"./idl/typeracer_escrow.json\";\n\n// Hard‑coded program ID\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst PROGRAM_ID = new PublicKey(idl.metadata.address);\nexport default function App() {\n  _s();\n  const {\n    connection\n  } = useConnection();\n  const wallet = useWallet();\n  const {\n    publicKey,\n    connected\n  } = wallet;\n  const walletAddress = (publicKey === null || publicKey === void 0 ? void 0 : publicKey.toBase58()) || \"\";\n  const providerRef = useRef(null);\n  useEffect(() => {\n    if (connected && connection) {\n      const prov = new anchor.AnchorProvider(connection, wallet, {\n        preflightCommitment: \"confirmed\"\n      });\n      anchor.setProvider(prov);\n      providerRef.current = prov;\n    }\n  }, [connected, connection, wallet]);\n  const [walletBalance, setWalletBalance] = useState(0);\n  useEffect(() => {\n    if (connection && publicKey) {\n      connection.getBalance(publicKey).then(lamports => {\n        setWalletBalance(lamports / LAMPORTS_PER_SOL);\n      });\n    }\n  }, [connection, publicKey]);\n  const [wager, setWager] = useState(1);\n  const [openMatches, setOpenMatches] = useState([]);\n  const [currentMatch, setCurrentMatch] = useState(null);\n  const [matchStatus, setMatchStatus] = useState(\"waiting\");\n  const [sentence, setSentence] = useState(\"\");\n  const [inputValue, setInputValue] = useState(\"\");\n  const [playerProgress, setPlayerProgress] = useState(0);\n  const [opponentProgress, setOpponentProgress] = useState(0);\n  const [countdown, setCountdown] = useState(3);\n  const [raceResult, setRaceResult] = useState(null);\n  const [isInputDisabled, setIsInputDisabled] = useState(false);\n  const [isAccepting, setIsAccepting] = useState(false);\n  const [opponentWallet, setOpponentWallet] = useState(null);\n  const [chatMessages, setChatMessages] = useState([]);\n  const [chatInput, setChatInput] = useState(\"\");\n  const [lastProgTime, setLastProgTime] = useState(Date.now());\n  const [lastProg, setLastProg] = useState(0);\n  const MAX_CPS = 20;\n  const inputRef = useRef(null);\n  const API = process.env.REACT_APP_API_URL;\n  useEffect(() => {\n    socket.connect();\n    socket.on(\"openMatches\", setOpenMatches);\n    socket.on(\"newMatch\", m => setOpenMatches(os => [...os, m]));\n    socket.on(\"removeMatch\", id => setOpenMatches(os => os.filter(m => m.id !== id)));\n    socket.on(\"startMatch\", ({\n      id,\n      players\n    }) => {\n      if ((currentMatch === null || currentMatch === void 0 ? void 0 : currentMatch.id) === id) {\n        setMatchStatus(\"ready\");\n        setSentence(chooseSentence(id));\n        setCountdown(3);\n        setOpponentWallet(players.find(w => w !== walletAddress));\n      }\n    });\n    socket.on(\"opponentProgress\", ({\n      wallet: w,\n      progress\n    }) => {\n      if (w !== walletAddress) setOpponentProgress(progress);\n    });\n    socket.on(\"raceEnd\", ({\n      winner,\n      progressMap\n    }) => {\n      setMatchStatus(\"finished\");\n      setIsInputDisabled(true);\n      setRaceResult({\n        result: winner === walletAddress ? \"win\" : \"lose\"\n      });\n      if (progressMap) {\n        var _progressMap$walletAd, _progressMap$opponent;\n        setPlayerProgress((_progressMap$walletAd = progressMap[walletAddress]) !== null && _progressMap$walletAd !== void 0 ? _progressMap$walletAd : 0);\n        setOpponentProgress((_progressMap$opponent = progressMap[opponentWallet]) !== null && _progressMap$opponent !== void 0 ? _progressMap$opponent : 0);\n      }\n    });\n    socket.on(\"chat\", setChatMessages);\n    socket.on(\"opponentLeft\", async () => {\n      if (matchStatus === \"finished\" && (raceResult === null || raceResult === void 0 ? void 0 : raceResult.result) === \"win\" && currentMatch !== null && currentMatch !== void 0 && currentMatch.id) {\n        try {\n          await resolveEscrow(new PublicKey(currentMatch.id), publicKey);\n        } catch (e) {\n          console.error(\"Auto‑claim failed:\", e);\n        }\n      }\n      resetGame();\n    });\n    return () => socket.removeAllListeners();\n  }, [connection, currentMatch, walletAddress, opponentWallet, matchStatus, raceResult, publicKey]);\n  useEffect(() => {\n    if (matchStatus === \"ready\" && countdown > 0) {\n      const t = setTimeout(() => setCountdown(c => c - 1), 1000);\n      return () => clearTimeout(t);\n    } else if (matchStatus === \"ready\" && countdown === 0) {\n      var _inputRef$current;\n      setMatchStatus(\"racing\");\n      setIsInputDisabled(false);\n      (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();\n    }\n  }, [countdown, matchStatus]);\n  const chooseSentence = id => sentences[Array.from(id).reduce((a, c) => a + c.charCodeAt(0), 0) % sentences.length];\n  const fetchOpenMatches = async () => {\n    try {\n      const res = await fetch(`${API}/wagers`);\n      setOpenMatches(await res.json());\n    } catch {}\n  };\n  const resetGame = () => {\n    setCurrentMatch(null);\n    setMatchStatus(\"waiting\");\n    setSentence(\"\");\n    setInputValue(\"\");\n    setPlayerProgress(0);\n    setOpponentProgress(0);\n    setCountdown(3);\n    setRaceResult(null);\n    setIsInputDisabled(false);\n    setOpponentWallet(null);\n    setLastProg(0);\n    setLastProgTime(Date.now());\n    fetchOpenMatches();\n  };\n\n  // ===== createMatch with vault PDA inclusion =====\n  async function createMatch() {\n    if (!connected) return alert(\"Connect your wallet first\");\n    const provider = providerRef.current;\n    if (!provider) return alert(\"Provider not ready\");\n    const lamports = Math.floor(wager * LAMPORTS_PER_SOL);\n    const program = new anchor.Program(idl, PROGRAM_ID, provider);\n    const nonce = Math.floor(Math.random() * 1000000);\n\n    // derive escrow PDA\n    const [escrowPda] = await PublicKey.findProgramAddress([Buffer.from(\"escrow\"), provider.wallet.publicKey.toBuffer(), new anchor.BN(nonce).toArrayLike(Buffer, \"le\", 8)], program.programId);\n\n    // derive vault PDA (must match your Rust seed)\n    const [vaultPda] = await PublicKey.findProgramAddress([Buffer.from(\"escrow_vault\"), escrowPda.toBuffer()], program.programId);\n\n    // init + deposit instructions\n    const ixInit = await program.methods.initialize(new anchor.BN(lamports), new anchor.BN(nonce)).accounts({\n      escrow: escrowPda,\n      player1: provider.wallet.publicKey,\n      authority: provider.wallet.publicKey,\n      systemProgram: SystemProgram.programId\n    }).instruction();\n    const ixDeposit = await program.methods.deposit().accounts({\n      escrow: escrowPda,\n      payer: provider.wallet.publicKey,\n      escrowAccount: escrowPda,\n      systemProgram: SystemProgram.programId\n    }).instruction();\n    const tx = new Transaction().add(ixInit, ixDeposit);\n    tx.feePayer = provider.wallet.publicKey;\n    const {\n      blockhash,\n      lastValidBlockHeight\n    } = await provider.connection.getLatestBlockhash(\"confirmed\");\n    tx.recentBlockhash = blockhash;\n    let signed;\n    try {\n      signed = await provider.wallet.signTransaction(tx);\n    } catch (err) {\n      return alert(\"Signing failed: \" + err.message);\n    }\n    try {\n      const sig = await provider.connection.sendRawTransaction(signed.serialize(), {\n        skipPreflight: false,\n        preflightCommitment: \"confirmed\"\n      });\n      await provider.connection.confirmTransaction({\n        signature: sig,\n        blockhash,\n        lastValidBlockHeight\n      }, \"confirmed\");\n    } catch (err) {\n      console.error(\"createMatch failed:\", err);\n      return alert(`Failed to create match:\\n${err.message || err}`);\n    }\n\n    // register match with vault\n    const id = escrowPda.toBase58();\n    await fetch(`${API}/wagers`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        id,\n        amount: Number(wager),\n        creator: walletAddress,\n        feePercent: 5,\n        vault: vaultPda.toBase58()\n      })\n    });\n    setCurrentMatch({\n      id,\n      amount: Number(wager),\n      creator: walletAddress,\n      vault: vaultPda.toBase58()\n    });\n    socket.emit(\"joinMatch\", id);\n    setMatchStatus(\"waiting\");\n  }\n\n  // ==== acceptMatch (similarly include vault) ====\n  async function acceptMatch(m) {\n    if (!connected) return alert(\"Connect your wallet first\");\n    setIsAccepting(true);\n    const provider = providerRef.current;\n    const pda = new PublicKey(m.id);\n\n    // deposit join_and_deposit\n    try {\n      await joinAndDeposit(pda);\n\n      // derive vault PDA the same way\n      const [vaultPda] = await PublicKey.findProgramAddress([Buffer.from(\"escrow_vault\"), pda.toBuffer()], PROGRAM_ID);\n      await fetch(`${API}/wagers/${m.id}/accept`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          accepter: walletAddress,\n          vault: vaultPda.toBase58()\n        })\n      });\n      setCurrentMatch({\n        ...m,\n        accepter: walletAddress,\n        vault: vaultPda.toBase58()\n      });\n      setMatchStatus(\"ready\");\n      setCountdown(3);\n      socket.emit(\"joinMatch\", m.id);\n    } catch (e) {\n      console.error(\"acceptMatch failed:\", e);\n      setCurrentMatch(null);\n      alert(`Failed to accept match:\\n${e.message || e}`);\n    } finally {\n      setIsAccepting(false);\n    }\n  }\n\n  // ==== cancel, input handlers, UI renderers unchanged ====  \n  async function cancelMatch(m) {\n    try {\n      await cancelEscrow(new PublicKey(m.id), new PublicKey(m.creator), new PublicKey(m.accepter || m.creator));\n      await fetch(`${API}/wagers/${m.id}/cancel`, {\n        method: \"POST\"\n      });\n      resetGame();\n    } catch (e) {\n      console.error(\"cancelMatch failed:\", e);\n      alert(`Failed to cancel match:\\n${e.message || e}`);\n    }\n  }\n  function handleInput(e) {\n    if (isInputDisabled) return;\n    if (e.type === \"paste\") {\n      e.preventDefault();\n      return;\n    }\n    const now = Date.now();\n    const val = e.target.value;\n    const rawProg = Math.min(1, val.length / sentence.length);\n    const deltaProg = rawProg - lastProg;\n    const deltaTime = (now - lastProgTime) / 1000;\n    const chars = deltaProg * sentence.length;\n    const cps = deltaTime > 0 ? chars / deltaTime : 0;\n    if (cps > MAX_CPS) return;\n    setLastProg(rawProg);\n    setLastProgTime(now);\n    setInputValue(val);\n    setPlayerProgress(rawProg);\n    socket.emit(\"progress\", {\n      matchId: currentMatch.id,\n      wallet: walletAddress,\n      progress: rawProg\n    });\n    if (val === sentence) {\n      fetch(`${API}/wagers/${currentMatch.id}/complete`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          winner: walletAddress\n        })\n      });\n      setMatchStatus(\"finished\");\n      setIsInputDisabled(true);\n      setRaceResult({\n        result: \"win\"\n      });\n    }\n  }\n\n  // Renderers omitted for brevity (use your existing renderMatchmaking,\n  // renderWaiting, renderRace, renderChat unchanged, just ensure\n  // createMatch and acceptMatch calls are updated above...)\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"app\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 348,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"ldBRgIm4aiKEkJ9uI+DoTqytkhA=\", false, function () {\n  return [useConnection, useWallet];\n});\n_c = App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","useRef","sentences","useConnection","useWallet","WalletMultiButton","LAMPORTS_PER_SOL","PublicKey","SystemProgram","Transaction","socket","anchor","initializeEscrow","joinAndDeposit","depositToEscrow","cancelEscrow","resolveEscrow","idl","jsxDEV","_jsxDEV","PROGRAM_ID","metadata","address","App","_s","connection","wallet","publicKey","connected","walletAddress","toBase58","providerRef","prov","AnchorProvider","preflightCommitment","setProvider","current","walletBalance","setWalletBalance","getBalance","then","lamports","wager","setWager","openMatches","setOpenMatches","currentMatch","setCurrentMatch","matchStatus","setMatchStatus","sentence","setSentence","inputValue","setInputValue","playerProgress","setPlayerProgress","opponentProgress","setOpponentProgress","countdown","setCountdown","raceResult","setRaceResult","isInputDisabled","setIsInputDisabled","isAccepting","setIsAccepting","opponentWallet","setOpponentWallet","chatMessages","setChatMessages","chatInput","setChatInput","lastProgTime","setLastProgTime","Date","now","lastProg","setLastProg","MAX_CPS","inputRef","API","process","env","REACT_APP_API_URL","connect","on","m","os","id","filter","players","chooseSentence","find","w","progress","winner","progressMap","result","_progressMap$walletAd","_progressMap$opponent","e","console","error","resetGame","removeAllListeners","t","setTimeout","c","clearTimeout","_inputRef$current","focus","Array","from","reduce","a","charCodeAt","length","fetchOpenMatches","res","fetch","json","createMatch","alert","provider","Math","floor","program","Program","nonce","random","escrowPda","findProgramAddress","Buffer","toBuffer","BN","toArrayLike","programId","vaultPda","ixInit","methods","initialize","accounts","escrow","player1","authority","systemProgram","instruction","ixDeposit","deposit","payer","escrowAccount","tx","add","feePayer","blockhash","lastValidBlockHeight","getLatestBlockhash","recentBlockhash","signed","signTransaction","err","message","sig","sendRawTransaction","serialize","skipPreflight","confirmTransaction","signature","method","headers","body","JSON","stringify","amount","Number","creator","feePercent","vault","emit","acceptMatch","pda","accepter","cancelMatch","handleInput","type","preventDefault","val","target","value","rawProg","min","deltaProg","deltaTime","chars","cps","matchId","className","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/kokoi/sol-wager-app/frontend/src/App.jsx"],"sourcesContent":["// src/App.jsx\n\nimport React, { useState, useEffect, useRef } from \"react\";\nimport \"./App.css\";\nimport sentences from \"./sentences\";\nimport { useConnection, useWallet } from \"@solana/wallet-adapter-react\";\nimport { WalletMultiButton } from \"@solana/wallet-adapter-react-ui\";\nimport {\n  LAMPORTS_PER_SOL,\n  PublicKey,\n  SystemProgram,\n  Transaction,\n} from \"@solana/web3.js\";\nimport socket from \"./socket\";\nimport * as anchor from \"@coral-xyz/anchor\";\nimport {\n  initializeEscrow,\n  joinAndDeposit,\n  depositToEscrow,\n  cancelEscrow,\n  resolveEscrow,\n} from \"./escrow\";\nimport idl from \"./idl/typeracer_escrow.json\";\n\n// Hard‑coded program ID\nconst PROGRAM_ID = new PublicKey(idl.metadata.address);\n\nexport default function App() {\n  const { connection } = useConnection();\n  const wallet = useWallet();\n  const { publicKey, connected } = wallet;\n  const walletAddress = publicKey?.toBase58() || \"\";\n\n  const providerRef = useRef(null);\n  useEffect(() => {\n    if (connected && connection) {\n      const prov = new anchor.AnchorProvider(connection, wallet, {\n        preflightCommitment: \"confirmed\",\n      });\n      anchor.setProvider(prov);\n      providerRef.current = prov;\n    }\n  }, [connected, connection, wallet]);\n\n  const [walletBalance, setWalletBalance] = useState(0);\n  useEffect(() => {\n    if (connection && publicKey) {\n      connection.getBalance(publicKey).then((lamports) => {\n        setWalletBalance(lamports / LAMPORTS_PER_SOL);\n      });\n    }\n  }, [connection, publicKey]);\n\n  const [wager, setWager] = useState(1);\n  const [openMatches, setOpenMatches] = useState([]);\n  const [currentMatch, setCurrentMatch] = useState(null);\n  const [matchStatus, setMatchStatus] = useState(\"waiting\");\n  const [sentence, setSentence] = useState(\"\");\n  const [inputValue, setInputValue] = useState(\"\");\n  const [playerProgress, setPlayerProgress] = useState(0);\n  const [opponentProgress, setOpponentProgress] = useState(0);\n  const [countdown, setCountdown] = useState(3);\n  const [raceResult, setRaceResult] = useState(null);\n  const [isInputDisabled, setIsInputDisabled] = useState(false);\n  const [isAccepting, setIsAccepting] = useState(false);\n  const [opponentWallet, setOpponentWallet] = useState(null);\n  const [chatMessages, setChatMessages] = useState([]);\n  const [chatInput, setChatInput] = useState(\"\");\n  const [lastProgTime, setLastProgTime] = useState(Date.now());\n  const [lastProg, setLastProg] = useState(0);\n  const MAX_CPS = 20;\n  const inputRef = useRef(null);\n  const API = process.env.REACT_APP_API_URL;\n\n  useEffect(() => {\n    socket.connect();\n    socket.on(\"openMatches\", setOpenMatches);\n    socket.on(\"newMatch\", (m) => setOpenMatches((os) => [...os, m]));\n    socket.on(\"removeMatch\", (id) =>\n      setOpenMatches((os) => os.filter((m) => m.id !== id))\n    );\n    socket.on(\"startMatch\", ({ id, players }) => {\n      if (currentMatch?.id === id) {\n        setMatchStatus(\"ready\");\n        setSentence(chooseSentence(id));\n        setCountdown(3);\n        setOpponentWallet(players.find((w) => w !== walletAddress));\n      }\n    });\n    socket.on(\"opponentProgress\", ({ wallet: w, progress }) => {\n      if (w !== walletAddress) setOpponentProgress(progress);\n    });\n    socket.on(\"raceEnd\", ({ winner, progressMap }) => {\n      setMatchStatus(\"finished\");\n      setIsInputDisabled(true);\n      setRaceResult({ result: winner === walletAddress ? \"win\" : \"lose\" });\n      if (progressMap) {\n        setPlayerProgress(progressMap[walletAddress] ?? 0);\n        setOpponentProgress(progressMap[opponentWallet] ?? 0);\n      }\n    });\n    socket.on(\"chat\", setChatMessages);\n    socket.on(\"opponentLeft\", async () => {\n      if (\n        matchStatus === \"finished\" &&\n        raceResult?.result === \"win\" &&\n        currentMatch?.id\n      ) {\n        try {\n          await resolveEscrow(new PublicKey(currentMatch.id), publicKey);\n        } catch (e) {\n          console.error(\"Auto‑claim failed:\", e);\n        }\n      }\n      resetGame();\n    });\n    return () => socket.removeAllListeners();\n  }, [\n    connection,\n    currentMatch,\n    walletAddress,\n    opponentWallet,\n    matchStatus,\n    raceResult,\n    publicKey,\n  ]);\n\n  useEffect(() => {\n    if (matchStatus === \"ready\" && countdown > 0) {\n      const t = setTimeout(() => setCountdown((c) => c - 1), 1000);\n      return () => clearTimeout(t);\n    } else if (matchStatus === \"ready\" && countdown === 0) {\n      setMatchStatus(\"racing\");\n      setIsInputDisabled(false);\n      inputRef.current?.focus();\n    }\n  }, [countdown, matchStatus]);\n\n  const chooseSentence = (id) =>\n    sentences[\n      Array.from(id).reduce((a, c) => a + c.charCodeAt(0), 0) %\n        sentences.length\n    ];\n\n  const fetchOpenMatches = async () => {\n    try {\n      const res = await fetch(`${API}/wagers`);\n      setOpenMatches(await res.json());\n    } catch {}\n  };\n\n  const resetGame = () => {\n    setCurrentMatch(null);\n    setMatchStatus(\"waiting\");\n    setSentence(\"\");\n    setInputValue(\"\");\n    setPlayerProgress(0);\n    setOpponentProgress(0);\n    setCountdown(3);\n    setRaceResult(null);\n    setIsInputDisabled(false);\n    setOpponentWallet(null);\n    setLastProg(0);\n    setLastProgTime(Date.now());\n    fetchOpenMatches();\n  };\n\n  // ===== createMatch with vault PDA inclusion =====\n  async function createMatch() {\n    if (!connected) return alert(\"Connect your wallet first\");\n    const provider = providerRef.current;\n    if (!provider) return alert(\"Provider not ready\");\n\n    const lamports = Math.floor(wager * LAMPORTS_PER_SOL);\n    const program = new anchor.Program(idl, PROGRAM_ID, provider);\n    const nonce = Math.floor(Math.random() * 1_000_000);\n\n    // derive escrow PDA\n    const [escrowPda] = await PublicKey.findProgramAddress(\n      [\n        Buffer.from(\"escrow\"),\n        provider.wallet.publicKey.toBuffer(),\n        new anchor.BN(nonce).toArrayLike(Buffer, \"le\", 8),\n      ],\n      program.programId\n    );\n\n    // derive vault PDA (must match your Rust seed)\n    const [vaultPda] = await PublicKey.findProgramAddress(\n      [Buffer.from(\"escrow_vault\"), escrowPda.toBuffer()],\n      program.programId\n    );\n\n    // init + deposit instructions\n    const ixInit = await program.methods\n      .initialize(new anchor.BN(lamports), new anchor.BN(nonce))\n      .accounts({\n        escrow: escrowPda,\n        player1: provider.wallet.publicKey,\n        authority: provider.wallet.publicKey,\n        systemProgram: SystemProgram.programId,\n      })\n      .instruction();\n\n    const ixDeposit = await program.methods\n      .deposit()\n      .accounts({\n        escrow: escrowPda,\n        payer: provider.wallet.publicKey,\n        escrowAccount: escrowPda,\n        systemProgram: SystemProgram.programId,\n      })\n      .instruction();\n\n    const tx = new Transaction().add(ixInit, ixDeposit);\n    tx.feePayer = provider.wallet.publicKey;\n    const { blockhash, lastValidBlockHeight } =\n      await provider.connection.getLatestBlockhash(\"confirmed\");\n    tx.recentBlockhash = blockhash;\n\n    let signed;\n    try {\n      signed = await provider.wallet.signTransaction(tx);\n    } catch (err) {\n      return alert(\"Signing failed: \" + err.message);\n    }\n\n    try {\n      const sig = await provider.connection.sendRawTransaction(\n        signed.serialize(),\n        { skipPreflight: false, preflightCommitment: \"confirmed\" }\n      );\n      await provider.connection.confirmTransaction(\n        { signature: sig, blockhash, lastValidBlockHeight },\n        \"confirmed\"\n      );\n    } catch (err) {\n      console.error(\"createMatch failed:\", err);\n      return alert(`Failed to create match:\\n${err.message || err}`);\n    }\n\n    // register match with vault\n    const id = escrowPda.toBase58();\n    await fetch(`${API}/wagers`, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        id,\n        amount: Number(wager),\n        creator: walletAddress,\n        feePercent: 5,\n        vault: vaultPda.toBase58(),\n      }),\n    });\n    setCurrentMatch({ id, amount: Number(wager), creator: walletAddress, vault: vaultPda.toBase58() });\n    socket.emit(\"joinMatch\", id);\n    setMatchStatus(\"waiting\");\n  }\n\n  // ==== acceptMatch (similarly include vault) ====\n  async function acceptMatch(m) {\n    if (!connected) return alert(\"Connect your wallet first\");\n    setIsAccepting(true);\n    const provider = providerRef.current;\n    const pda = new PublicKey(m.id);\n\n    // deposit join_and_deposit\n    try {\n      await joinAndDeposit(pda);\n\n      // derive vault PDA the same way\n      const [vaultPda] = await PublicKey.findProgramAddress(\n        [Buffer.from(\"escrow_vault\"), pda.toBuffer()],\n        PROGRAM_ID\n      );\n\n      await fetch(`${API}/wagers/${m.id}/accept`, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ accepter: walletAddress, vault: vaultPda.toBase58() }),\n      });\n      setCurrentMatch({ ...m, accepter: walletAddress, vault: vaultPda.toBase58() });\n      setMatchStatus(\"ready\");\n      setCountdown(3);\n      socket.emit(\"joinMatch\", m.id);\n    } catch (e) {\n      console.error(\"acceptMatch failed:\", e);\n      setCurrentMatch(null);\n      alert(`Failed to accept match:\\n${e.message || e}`);\n    } finally {\n      setIsAccepting(false);\n    }\n  }\n\n  // ==== cancel, input handlers, UI renderers unchanged ====  \n  async function cancelMatch(m) {\n    try {\n      await cancelEscrow(\n        new PublicKey(m.id),\n        new PublicKey(m.creator),\n        new PublicKey(m.accepter || m.creator)\n      );\n      await fetch(`${API}/wagers/${m.id}/cancel`, { method: \"POST\" });\n      resetGame();\n    } catch (e) {\n      console.error(\"cancelMatch failed:\", e);\n      alert(`Failed to cancel match:\\n${e.message || e}`);\n    }\n  }\n\n  function handleInput(e) {\n    if (isInputDisabled) return;\n    if (e.type === \"paste\") { e.preventDefault(); return; }\n    const now = Date.now();\n    const val = e.target.value;\n    const rawProg = Math.min(1, val.length / sentence.length);\n    const deltaProg = rawProg - lastProg;\n    const deltaTime = (now - lastProgTime) / 1000;\n    const chars = deltaProg * sentence.length;\n    const cps = deltaTime > 0 ? chars / deltaTime : 0;\n    if (cps > MAX_CPS) return;\n    setLastProg(rawProg);\n    setLastProgTime(now);\n    setInputValue(val);\n    setPlayerProgress(rawProg);\n    socket.emit(\"progress\", {\n      matchId: currentMatch.id,\n      wallet: walletAddress,\n      progress: rawProg,\n    });\n    if (val === sentence) {\n      fetch(`${API}/wagers/${currentMatch.id}/complete`, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ winner: walletAddress }),\n      });\n      setMatchStatus(\"finished\");\n      setIsInputDisabled(true);\n      setRaceResult({ result: \"win\" });\n    }\n  }\n\n  // Renderers omitted for brevity (use your existing renderMatchmaking,\n  // renderWaiting, renderRace, renderChat unchanged, just ensure\n  // createMatch and acceptMatch calls are updated above...)\n\n  return (\n    <div className=\"app\">\n      {/* ... your header and conditional renders as before ... */}\n    </div>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}